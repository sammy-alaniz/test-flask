
## Overview
You are a code assistant that accepts a python test file, and a python included files.
Your goal is to generate one and only one additional unit test to complement the existing test suite, 
in order to increase the code coverage against the source file.

## Test File
Here is the test file that you will be writing tests against, called `test_blueprints.py`.
=========
import pytest
from jinja2 import TemplateNotFound
from werkzeug.http import parse_cache_control_header

import flask


def test_blueprint_specific_error_handling(app, client):
    frontend = flask.Blueprint("frontend", __name__)
    backend = flask.Blueprint("backend", __name__)
    sideend = flask.Blueprint("sideend", __name__)

    @frontend.errorhandler(403)
    def frontend_forbidden(e):
        return "frontend says no", 403

    @frontend.route("/frontend-no")
    def frontend_no():
        flask.abort(403)

    @backend.errorhandler(403)
    def backend_forbidden(e):
        return "backend says no", 403

    @backend.route("/backend-no")
    def backend_no():
        flask.abort(403)

    @sideend.route("/what-is-a-sideend")
    def sideend_no():
        flask.abort(403)

    app.register_blueprint(frontend)
    app.register_blueprint(backend)
    app.register_blueprint(sideend)

    @app.errorhandler(403)
    def app_forbidden(e):
        return "application itself says no", 403

    assert client.get("/frontend-no").data == b"frontend says no"
    assert client.get("/backend-no").data == b"backend says no"
    assert client.get("/what-is-a-sideend").data == b"application itself says no"


def test_blueprint_specific_user_error_handling(app, client):
    class MyDecoratorException(Exception):
        pass

    class MyFunctionException(Exception):
        pass

    blue = flask.Blueprint("blue", __name__)

    @blue.errorhandler(MyDecoratorException)
    def my_decorator_exception_handler(e):
        assert isinstance(e, MyDecoratorException)
        return "boom"

    def my_function_exception_handler(e):
        assert isinstance(e, MyFunctionException)
        return "bam"

    blue.register_error_handler(MyFunctionException, my_function_exception_handler)

    @blue.route("/decorator")
    def blue_deco_test():
        raise MyDecoratorException()

    @blue.route("/function")
    def blue_func_test():
        raise MyFunctionException()

    app.register_blueprint(blue)

    assert client.get("/decorator").data == b"boom"
    assert client.get("/function").data == b"bam"


def test_blueprint_app_error_handling(app, client):
    errors = flask.Blueprint("errors", __name__)

    @errors.app_errorhandler(403)
    def forbidden_handler(e):
        return "you shall not pass", 403

    @app.route("/forbidden")
    def app_forbidden():
        flask.abort(403)

    forbidden_bp = flask.Blueprint("forbidden_bp", __name__)

    @forbidden_bp.route("/nope")
    def bp_forbidden():
        flask.abort(403)

    app.register_blueprint(errors)
    app.register_blueprint(forbidden_bp)

    assert client.get("/forbidden").data == b"you shall not pass"
    assert client.get("/nope").data == b"you shall not pass"


@pytest.mark.parametrize(
    ("prefix", "rule", "url"),
    (
        ("", "/", "/"),
        ("/", "", "/"),
        ("/", "/", "/"),
        ("/foo", "", "/foo"),
        ("/foo/", "", "/foo/"),
        ("", "/bar", "/bar"),
        ("/foo/", "/bar", "/foo/bar"),
        ("/foo/", "bar", "/foo/bar"),
        ("/foo", "/bar", "/foo/bar"),
        ("/foo/", "//bar", "/foo/bar"),
        ("/foo//", "/bar", "/foo/bar"),
    ),
)
def test_blueprint_prefix_slash(app, client, prefix, rule, url):
    bp = flask.Blueprint("test", __name__, url_prefix=prefix)

    @bp.route(rule)
    def index():
        return "", 204

    app.register_blueprint(bp)
    assert client.get(url).status_code == 204


def test_blueprint_url_defaults(app, client):
    bp = flask.Blueprint("test", __name__)

    @bp.route("/foo", defaults={"baz": 42})
    def foo(bar, baz):
        return f"{bar}/{baz:d}"

    @bp.route("/bar")
    def bar(bar):
        return str(bar)

    app.register_blueprint(bp, url_prefix="/1", url_defaults={"bar": 23})
    app.register_blueprint(bp, name="test2", url_prefix="/2", url_defaults={"bar": 19})

    assert client.get("/1/foo").data == b"23/42"
    assert client.get("/2/foo").data == b"19/42"
    assert client.get("/1/bar").data == b"23"
    assert client.get("/2/bar").data == b"19"


def test_blueprint_url_processors(app, client):
    bp = flask.Blueprint("frontend", __name__, url_prefix="/<lang_code>")

    @bp.url_defaults
    def add_language_code(endpoint, values):
        values.setdefault("lang_code", flask.g.lang_code)

    @bp.url_value_preprocessor
    def pull_lang_code(endpoint, values):
        flask.g.lang_code = values.pop("lang_code")

    @bp.route("/")
    def index():
        return flask.url_for(".about")

    @bp.route("/about")
    def about():
        return flask.url_for(".index")

    app.register_blueprint(bp)

    assert client.get("/de/").data == b"/de/about"
    assert client.get("/de/about").data == b"/de/"


def test_templates_and_static(test_apps):
    from blueprintapp import app

    client = app.test_client()

    rv = client.get("/")
    assert rv.data == b"Hello from the Frontend"
    rv = client.get("/admin/")
    assert rv.data == b"Hello from the Admin"
    rv = client.get("/admin/index2")
    assert rv.data == b"Hello from the Admin"
    rv = client.get("/admin/static/test.txt")
    assert rv.data.strip() == b"Admin File"
    rv.close()
    rv = client.get("/admin/static/css/test.css")
    assert rv.data.strip() == b"/* nested file */"
    rv.close()

    # try/finally, in case other tests use this app for Blueprint tests.
    max_age_default = app.config["SEND_FILE_MAX_AGE_DEFAULT"]
    try:
        expected_max_age = 3600
        if app.config["SEND_FILE_MAX_AGE_DEFAULT"] == expected_max_age:
            expected_max_age = 7200
        app.config["SEND_FILE_MAX_AGE_DEFAULT"] = expected_max_age
        rv = client.get("/admin/static/css/test.css")
        cc = parse_cache_control_header(rv.headers["Cache-Control"])
        assert cc.max_age == expected_max_age
        rv.close()
    finally:
        app.config["SEND_FILE_MAX_AGE_DEFAULT"] = max_age_default

    with app.test_request_context():
        assert (
            flask.url_for("admin.static", filename="test.txt")
            == "/admin/static/test.txt"
        )

    with app.test_request_context():
        with pytest.raises(TemplateNotFound) as e:
            flask.render_template("missing.html")
        assert e.value.name == "missing.html"

    with flask.Flask(__name__).test_request_context():
        assert flask.render_template("nested/nested.txt") == "I'm nested"


def test_default_static_max_age(app):
    class MyBlueprint(flask.Blueprint):
        def get_send_file_max_age(self, filename):
            return 100

    blueprint = MyBlueprint("blueprint", __name__, static_folder="static")
    app.register_blueprint(blueprint)

    # try/finally, in case other tests use this app for Blueprint tests.
    max_age_default = app.config["SEND_FILE_MAX_AGE_DEFAULT"]
    try:
        with app.test_request_context():
            unexpected_max_age = 3600
            if app.config["SEND_FILE_MAX_AGE_DEFAULT"] == unexpected_max_age:
                unexpected_max_age = 7200
            app.config["SEND_FILE_MAX_AGE_DEFAULT"] = unexpected_max_age
            rv = blueprint.send_static_file("index.html")
            cc = parse_cache_control_header(rv.headers["Cache-Control"])
            assert cc.max_age == 100
            rv.close()
    finally:
        app.config["SEND_FILE_MAX_AGE_DEFAULT"] = max_age_default


def test_templates_list(test_apps):
    from blueprintapp import app

    templates = sorted(app.jinja_env.list_templates())
    assert templates == ["admin/index.html", "frontend/index.html"]


def test_dotted_name_not_allowed(app, client):
    with pytest.raises(ValueError):
        flask.Blueprint("app.ui", __name__)


def test_empty_name_not_allowed(app, client):
    with pytest.raises(ValueError):
        flask.Blueprint("", __name__)


def test_dotted_names_from_app(app, client):
    test = flask.Blueprint("test", __name__)

    @app.route("/")
    def app_index():
        return flask.url_for("test.index")

    @test.route("/test/")
    def index():
        return flask.url_for("app_index")

    app.register_blueprint(test)

    rv = client.get("/")
    assert rv.data == b"/test/"


def test_empty_url_defaults(app, client):
    bp = flask.Blueprint("bp", __name__)

    @bp.route("/", defaults={"page": 1})
    @bp.route("/page/<int:page>")
    def something(page):
        return str(page)

    app.register_blueprint(bp)

    assert client.get("/").data == b"1"
    assert client.get("/page/2").data == b"2"


def test_route_decorator_custom_endpoint(app, client):
    bp = flask.Blueprint("bp", __name__)

    @bp.route("/foo")
    def foo():
        return flask.request.endpoint

    @bp.route("/bar", endpoint="bar")
    def foo_bar():
        return flask.request.endpoint

    @bp.route("/bar/123", endpoint="123")
    def foo_bar_foo():
        return flask.request.endpoint

    @bp.route("/bar/foo")
    def bar_foo():
        return flask.request.endpoint

    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.request.endpoint

    assert client.get("/").data == b"index"
    assert client.get("/py/foo").data == b"bp.foo"
    assert client.get("/py/bar").data == b"bp.bar"
    assert client.get("/py/bar/123").data == b"bp.123"
    assert client.get("/py/bar/foo").data == b"bp.bar_foo"


def test_route_decorator_custom_endpoint_with_dots(app, client):
    bp = flask.Blueprint("bp", __name__)

    with pytest.raises(ValueError):
        bp.route("/", endpoint="a.b")(lambda: "")

    with pytest.raises(ValueError):
        bp.add_url_rule("/", endpoint="a.b")

    def view():
        return ""

    view.__name__ = "a.b"

    with pytest.raises(ValueError):
        bp.add_url_rule("/", view_func=view)


def test_endpoint_decorator(app, client):
    from werkzeug.routing import Rule

    app.url_map.add(Rule("/foo", endpoint="bar"))

    bp = flask.Blueprint("bp", __name__)

    @bp.endpoint("bar")
    def foobar():
        return flask.request.endpoint

    app.register_blueprint(bp, url_prefix="/bp_prefix")

    assert client.get("/foo").data == b"bar"
    assert client.get("/bp_prefix/bar").status_code == 404


def test_template_filter(app):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_filter()
    def my_reverse(s):
        return s[::-1]

    app.register_blueprint(bp, url_prefix="/py")
    assert "my_reverse" in app.jinja_env.filters.keys()
    assert app.jinja_env.filters["my_reverse"] == my_reverse
    assert app.jinja_env.filters["my_reverse"]("abcd") == "dcba"


def test_add_template_filter(app):
    bp = flask.Blueprint("bp", __name__)

    def my_reverse(s):
        return s[::-1]

    bp.add_app_template_filter(my_reverse)
    app.register_blueprint(bp, url_prefix="/py")
    assert "my_reverse" in app.jinja_env.filters.keys()
    assert app.jinja_env.filters["my_reverse"] == my_reverse
    assert app.jinja_env.filters["my_reverse"]("abcd") == "dcba"


def test_template_filter_with_name(app):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_filter("strrev")
    def my_reverse(s):
        return s[::-1]

    app.register_blueprint(bp, url_prefix="/py")
    assert "strrev" in app.jinja_env.filters.keys()
    assert app.jinja_env.filters["strrev"] == my_reverse
    assert app.jinja_env.filters["strrev"]("abcd") == "dcba"


def test_add_template_filter_with_name(app):
    bp = flask.Blueprint("bp", __name__)

    def my_reverse(s):
        return s[::-1]

    bp.add_app_template_filter(my_reverse, "strrev")
    app.register_blueprint(bp, url_prefix="/py")
    assert "strrev" in app.jinja_env.filters.keys()
    assert app.jinja_env.filters["strrev"] == my_reverse
    assert app.jinja_env.filters["strrev"]("abcd") == "dcba"


def test_template_filter_with_template(app, client):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_filter()
    def super_reverse(s):
        return s[::-1]

    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.render_template("template_filter.html", value="abcd")

    rv = client.get("/")
    assert rv.data == b"dcba"


def test_template_filter_after_route_with_template(app, client):
    @app.route("/")
    def index():
        return flask.render_template("template_filter.html", value="abcd")

    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_filter()
    def super_reverse(s):
        return s[::-1]

    app.register_blueprint(bp, url_prefix="/py")
    rv = client.get("/")
    assert rv.data == b"dcba"


def test_add_template_filter_with_template(app, client):
    bp = flask.Blueprint("bp", __name__)

    def super_reverse(s):
        return s[::-1]

    bp.add_app_template_filter(super_reverse)
    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.render_template("template_filter.html", value="abcd")

    rv = client.get("/")
    assert rv.data == b"dcba"


def test_template_filter_with_name_and_template(app, client):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_filter("super_reverse")
    def my_reverse(s):
        return s[::-1]

    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.render_template("template_filter.html", value="abcd")

    rv = client.get("/")
    assert rv.data == b"dcba"


def test_add_template_filter_with_name_and_template(app, client):
    bp = flask.Blueprint("bp", __name__)

    def my_reverse(s):
        return s[::-1]

    bp.add_app_template_filter(my_reverse, "super_reverse")
    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.render_template("template_filter.html", value="abcd")

    rv = client.get("/")
    assert rv.data == b"dcba"


def test_template_test(app):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_test()
    def is_boolean(value):
        return isinstance(value, bool)

    app.register_blueprint(bp, url_prefix="/py")
    assert "is_boolean" in app.jinja_env.tests.keys()
    assert app.jinja_env.tests["is_boolean"] == is_boolean
    assert app.jinja_env.tests["is_boolean"](False)


def test_add_template_test(app):
    bp = flask.Blueprint("bp", __name__)

    def is_boolean(value):
        return isinstance(value, bool)

    bp.add_app_template_test(is_boolean)
    app.register_blueprint(bp, url_prefix="/py")
    assert "is_boolean" in app.jinja_env.tests.keys()
    assert app.jinja_env.tests["is_boolean"] == is_boolean
    assert app.jinja_env.tests["is_boolean"](False)


def test_template_test_with_name(app):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_test("boolean")
    def is_boolean(value):
        return isinstance(value, bool)

    app.register_blueprint(bp, url_prefix="/py")
    assert "boolean" in app.jinja_env.tests.keys()
    assert app.jinja_env.tests["boolean"] == is_boolean
    assert app.jinja_env.tests["boolean"](False)


def test_add_template_test_with_name(app):
    bp = flask.Blueprint("bp", __name__)

    def is_boolean(value):
        return isinstance(value, bool)

    bp.add_app_template_test(is_boolean, "boolean")
    app.register_blueprint(bp, url_prefix="/py")
    assert "boolean" in app.jinja_env.tests.keys()
    assert app.jinja_env.tests["boolean"] == is_boolean
    assert app.jinja_env.tests["boolean"](False)


def test_template_test_with_template(app, client):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_test()
    def boolean(value):
        return isinstance(value, bool)

    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.render_template("template_test.html", value=False)

    rv = client.get("/")
    assert b"Success!" in rv.data


def test_template_test_after_route_with_template(app, client):
    @app.route("/")
    def index():
        return flask.render_template("template_test.html", value=False)

    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_test()
    def boolean(value):
        return isinstance(value, bool)

    app.register_blueprint(bp, url_prefix="/py")
    rv = client.get("/")
    assert b"Success!" in rv.data


def test_add_template_test_with_template(app, client):
    bp = flask.Blueprint("bp", __name__)

    def boolean(value):
        return isinstance(value, bool)

    bp.add_app_template_test(boolean)
    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.render_template("template_test.html", value=False)

    rv = client.get("/")
    assert b"Success!" in rv.data


def test_template_test_with_name_and_template(app, client):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_test("boolean")
    def is_boolean(value):
        return isinstance(value, bool)

    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.render_template("template_test.html", value=False)

    rv = client.get("/")
    assert b"Success!" in rv.data


def test_add_template_test_with_name_and_template(app, client):
    bp = flask.Blueprint("bp", __name__)

    def is_boolean(value):
        return isinstance(value, bool)

    bp.add_app_template_test(is_boolean, "boolean")
    app.register_blueprint(bp, url_prefix="/py")

    @app.route("/")
    def index():
        return flask.render_template("template_test.html", value=False)

    rv = client.get("/")
    assert b"Success!" in rv.data


def test_context_processing(app, client):
    answer_bp = flask.Blueprint("answer_bp", __name__)

    def template_string():
        return flask.render_template_string(
            "{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}"
            "{% if answer %}{{ answer }} is the answer.{% endif %}"
        )

    # App global context processor
    @answer_bp.app_context_processor
    def not_answer_context_processor():
        return {"notanswer": 43}

    # Blueprint local context processor
    @answer_bp.context_processor
    def answer_context_processor():
        return {"answer": 42}

    # Setup endpoints for testing
    @answer_bp.route("/bp")
    def bp_page():
        return template_string()

    @app.route("/")
    def app_page():
        return template_string()

    # Register the blueprint
    app.register_blueprint(answer_bp)

    app_page_bytes = client.get("/").data
    answer_page_bytes = client.get("/bp").data

    assert b"43" in app_page_bytes
    assert b"42" not in app_page_bytes

    assert b"42" in answer_page_bytes
    assert b"43" in answer_page_bytes


def test_template_global(app):
    bp = flask.Blueprint("bp", __name__)

    @bp.app_template_global()
    def get_answer():
        return 42

    # Make sure the function is not in the jinja_env already
    assert "get_answer" not in app.jinja_env.globals.keys()
    app.register_blueprint(bp)

    # Tests
    assert "get_answer" in app.jinja_env.globals.keys()
    assert app.jinja_env.globals["get_answer"] is get_answer
    assert app.jinja_env.globals["get_answer"]() == 42

    with app.app_context():
        rv = flask.render_template_string("{{ get_answer() }}")
        assert rv == "42"


def test_request_processing(app, client):
    bp = flask.Blueprint("bp", __name__)
    evts = []

    @bp.before_request
    def before_bp():
        evts.append("before")

    @bp.after_request
    def after_bp(response):
        response.data += b"|after"
        evts.append("after")
        return response

    @bp.teardown_request
    def teardown_bp(exc):
        evts.append("teardown")

    # Setup routes for testing
    @bp.route("/bp")
    def bp_endpoint():
        return "request"

    app.register_blueprint(bp)

    assert evts == []
    rv = client.get("/bp")
    assert rv.data == b"request|after"
    assert evts == ["before", "after", "teardown"]


def test_app_request_processing(app, client):
    bp = flask.Blueprint("bp", __name__)
    evts = []

    @bp.before_app_request
    def before_app():
        evts.append("before")

    @bp.after_app_request
    def after_app(response):
        response.data += b"|after"
        evts.append("after")
        return response

    @bp.teardown_app_request
    def teardown_app(exc):
        evts.append("teardown")

    app.register_blueprint(bp)

    # Setup routes for testing
    @app.route("/")
    def bp_endpoint():
        return "request"

    # before first request
    assert evts == []

    # first request
    resp = client.get("/").data
    assert resp == b"request|after"
    assert evts == ["before", "after", "teardown"]

    # second request
    resp = client.get("/").data
    assert resp == b"request|after"
    assert evts == ["before", "after", "teardown"] * 2


def test_app_url_processors(app, client):
    bp = flask.Blueprint("bp", __name__)

    # Register app-wide url defaults and preprocessor on blueprint
    @bp.app_url_defaults
    def add_language_code(endpoint, values):
        values.setdefault("lang_code", flask.g.lang_code)

    @bp.app_url_value_preprocessor
    def pull_lang_code(endpoint, values):
        flask.g.lang_code = values.pop("lang_code")

    # Register route rules at the app level
    @app.route("/<lang_code>/")
    def index():
        return flask.url_for("about")

    @app.route("/<lang_code>/about")
    def about():
        return flask.url_for("index")

    app.register_blueprint(bp)

    assert client.get("/de/").data == b"/de/about"
    assert client.get("/de/about").data == b"/de/"


def test_nested_blueprint(app, client):
    parent = flask.Blueprint("parent", __name__)
    child = flask.Blueprint("child", __name__)
    grandchild = flask.Blueprint("grandchild", __name__)

    @parent.errorhandler(403)
    def forbidden(e):
        return "Parent no", 403

    @parent.route("/")
    def parent_index():
        return "Parent yes"

    @parent.route("/no")
    def parent_no():
        flask.abort(403)

    @child.route("/")
    def child_index():
        return "Child yes"

    @child.route("/no")
    def child_no():
        flask.abort(403)

    @grandchild.errorhandler(403)
    def grandchild_forbidden(e):
        return "Grandchild no", 403

    @grandchild.route("/")
    def grandchild_index():
        return "Grandchild yes"

    @grandchild.route("/no")
    def grandchild_no():
        flask.abort(403)

    child.register_blueprint(grandchild, url_prefix="/grandchild")
    parent.register_blueprint(child, url_prefix="/child")
    app.register_blueprint(parent, url_prefix="/parent")

    assert client.get("/parent/").data == b"Parent yes"
    assert client.get("/parent/child/").data == b"Child yes"
    assert client.get("/parent/child/grandchild/").data == b"Grandchild yes"
    assert client.get("/parent/no").data == b"Parent no"
    assert client.get("/parent/child/no").data == b"Parent no"
    assert client.get("/parent/child/grandchild/no").data == b"Grandchild no"


def test_nested_callback_order(app, client):
    parent = flask.Blueprint("parent", __name__)
    child = flask.Blueprint("child", __name__)

    @app.before_request
    def app_before1():
        flask.g.setdefault("seen", []).append("app_1")

    @app.teardown_request
    def app_teardown1(e=None):
        assert flask.g.seen.pop() == "app_1"

    @app.before_request
    def app_before2():
        flask.g.setdefault("seen", []).append("app_2")

    @app.teardown_request
    def app_teardown2(e=None):
        assert flask.g.seen.pop() == "app_2"

    @app.context_processor
    def app_ctx():
        return dict(key="app")

    @parent.before_request
    def parent_before1():
        flask.g.setdefault("seen", []).append("parent_1")

    @parent.teardown_request
    def parent_teardown1(e=None):
        assert flask.g.seen.pop() == "parent_1"

    @parent.before_request
    def parent_before2():
        flask.g.setdefault("seen", []).append("parent_2")

    @parent.teardown_request
    def parent_teardown2(e=None):
        assert flask.g.seen.pop() == "parent_2"

    @parent.context_processor
    def parent_ctx():
        return dict(key="parent")

    @child.before_request
    def child_before1():
        flask.g.setdefault("seen", []).append("child_1")

    @child.teardown_request
    def child_teardown1(e=None):
        assert flask.g.seen.pop() == "child_1"

    @child.before_request
    def child_before2():
        flask.g.setdefault("seen", []).append("child_2")

    @child.teardown_request
    def child_teardown2(e=None):
        assert flask.g.seen.pop() == "child_2"

    @child.context_processor
    def child_ctx():
        return dict(key="child")

    @child.route("/a")
    def a():
        return ", ".join(flask.g.seen)

    @child.route("/b")
    def b():
        return flask.render_template_string("{{ key }}")

    parent.register_blueprint(child)
    app.register_blueprint(parent)
    assert (
        client.get("/a").data == b"app_1, app_2, parent_1, parent_2, child_1, child_2"
    )
    assert client.get("/b").data == b"child"


@pytest.mark.parametrize(
    "parent_init, child_init, parent_registration, child_registration",
    [
        ("/parent", "/child", None, None),
        ("/parent", None, None, "/child"),
        (None, None, "/parent", "/child"),
        ("/other", "/something", "/parent", "/child"),
    ],
)
def test_nesting_url_prefixes(
    parent_init,
    child_init,
    parent_registration,
    child_registration,
    app,
    client,
) -> None:
    parent = flask.Blueprint("parent", __name__, url_prefix=parent_init)
    child = flask.Blueprint("child", __name__, url_prefix=child_init)

    @child.route("/")
    def index():
        return "index"

    parent.register_blueprint(child, url_prefix=child_registration)
    app.register_blueprint(parent, url_prefix=parent_registration)

    response = client.get("/parent/child/")
    assert response.status_code == 200


def test_nesting_subdomains(app, client) -> None:
    subdomain = "api"
    parent = flask.Blueprint("parent", __name__)
    child = flask.Blueprint("child", __name__)

    @child.route("/child/")
    def index():
        return "child"

    parent.register_blueprint(child)
    app.register_blueprint(parent, subdomain=subdomain)

    client.allow_subdomain_redirects = True

    domain_name = "domain.tld"
    app.config["SERVER_NAME"] = domain_name
    response = client.get("/child/", base_url="http://api." + domain_name)

    assert response.status_code == 200


def test_child_and_parent_subdomain(app, client) -> None:
    child_subdomain = "api"
    parent_subdomain = "parent"
    parent = flask.Blueprint("parent", __name__)
    child = flask.Blueprint("child", __name__, subdomain=child_subdomain)

    @child.route("/")
    def index():
        return "child"

    parent.register_blueprint(child)
    app.register_blueprint(parent, subdomain=parent_subdomain)

    client.allow_subdomain_redirects = True

    domain_name = "domain.tld"
    app.config["SERVER_NAME"] = domain_name
    response = client.get(
        "/", base_url=f"http://{child_subdomain}.{parent_subdomain}.{domain_name}"
    )

    assert response.status_code == 200

    response = client.get("/", base_url=f"http://{parent_subdomain}.{domain_name}")

    assert response.status_code == 404


def test_unique_blueprint_names(app, client) -> None:
    bp = flask.Blueprint("bp", __name__)
    bp2 = flask.Blueprint("bp", __name__)

    app.register_blueprint(bp)

    with pytest.raises(ValueError):
        app.register_blueprint(bp)  # same bp, same name, error

    app.register_blueprint(bp, name="again")  # same bp, different name, ok

    with pytest.raises(ValueError):
        app.register_blueprint(bp2)  # different bp, same name, error

    app.register_blueprint(bp2, name="alt")  # different bp, different name, ok


def test_self_registration(app, client) -> None:
    bp = flask.Blueprint("bp", __name__)
    with pytest.raises(ValueError):
        bp.register_blueprint(bp)


def test_blueprint_renaming(app, client) -> None:
    bp = flask.Blueprint("bp", __name__)
    bp2 = flask.Blueprint("bp2", __name__)

    @bp.get("/")
    def index():
        return flask.request.endpoint

    @bp.get("/error")
    def error():
        flask.abort(403)

    @bp.errorhandler(403)
    def forbidden(_: Exception):
        return "Error", 403

    @bp2.get("/")
    def index2():
        return flask.request.endpoint

    bp.register_blueprint(bp2, url_prefix="/a", name="sub")
    app.register_blueprint(bp, url_prefix="/a")
    app.register_blueprint(bp, url_prefix="/b", name="alt")

    assert client.get("/a/").data == b"bp.index"
    assert client.get("/b/").data == b"alt.index"
    assert client.get("/a/a/").data == b"bp.sub.index2"
    assert client.get("/b/a/").data == b"alt.sub.index2"
    assert client.get("/a/error").data == b"Error"
    assert client.get("/b/error").data == b"Error"

=========

## Included Files
Here are the included files that you will be writing tests against.
Note that we have manually added line numbers for each line of code, to help you understand increasing code coverage.
Those numbers are not a part of the original code.

FILE NAME : app.py =====
1 from __future__ import annotations
2 
3 import collections.abc as cabc
4 import os
5 import sys
6 import typing as t
7 import weakref
8 from datetime import timedelta
9 from inspect import iscoroutinefunction
10 from itertools import chain
11 from types import TracebackType
12 from urllib.parse import quote as _url_quote
13 
14 import click
15 from werkzeug.datastructures import Headers
16 from werkzeug.datastructures import ImmutableDict
17 from werkzeug.exceptions import BadRequestKeyError
18 from werkzeug.exceptions import HTTPException
19 from werkzeug.exceptions import InternalServerError
20 from werkzeug.routing import BuildError
21 from werkzeug.routing import MapAdapter
22 from werkzeug.routing import RequestRedirect
23 from werkzeug.routing import RoutingException
24 from werkzeug.routing import Rule
25 from werkzeug.serving import is_running_from_reloader
26 from werkzeug.wrappers import Response as BaseResponse
27 
28 from . import cli
29 from . import typing as ft
30 from .ctx import AppContext
31 from .ctx import RequestContext
32 from .globals import _cv_app
33 from .globals import _cv_request
34 from .globals import current_app
35 from .globals import g
36 from .globals import request
37 from .globals import request_ctx
38 from .globals import session
39 from .helpers import get_debug_flag
40 from .helpers import get_flashed_messages
41 from .helpers import get_load_dotenv
42 from .helpers import send_from_directory
43 from .sansio.app import App
44 from .sansio.scaffold import _sentinel
45 from .sessions import SecureCookieSessionInterface
46 from .sessions import SessionInterface
47 from .signals import appcontext_tearing_down
48 from .signals import got_request_exception
49 from .signals import request_finished
50 from .signals import request_started
51 from .signals import request_tearing_down
52 from .templating import Environment
53 from .wrappers import Request
54 from .wrappers import Response
55 
56 if t.TYPE_CHECKING:  # pragma: no cover
57     from _typeshed.wsgi import StartResponse
58     from _typeshed.wsgi import WSGIEnvironment
59 
60     from .testing import FlaskClient
61     from .testing import FlaskCliRunner
62 
63 T_shell_context_processor = t.TypeVar(
64     "T_shell_context_processor", bound=ft.ShellContextProcessorCallable
65 )
66 T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
67 T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
68 T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
69 T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
70 
71 
72 def _make_timedelta(value: timedelta | int | None) -> timedelta | None:
73     if value is None or isinstance(value, timedelta):
74         return value
75 
76     return timedelta(seconds=value)
77 
78 
79 class Flask(App):
80     """The flask object implements a WSGI application and acts as the central
81     object.  It is passed the name of the module or package of the
82     application.  Once it is created it will act as a central registry for
83     the view functions, the URL rules, template configuration and much more.
84 
85     The name of the package is used to resolve resources from inside the
86     package or the folder the module is contained in depending on if the
87     package parameter resolves to an actual python package (a folder with
88     an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).
89 
90     For more information about resource loading, see :func:`open_resource`.
91 
92     Usually you create a :class:`Flask` instance in your main module or
93     in the :file:`__init__.py` file of your package like this::
94 
95         from flask import Flask
96         app = Flask(__name__)
97 
98     .. admonition:: About the First Parameter
99 
100         The idea of the first parameter is to give Flask an idea of what
101         belongs to your application.  This name is used to find resources
102         on the filesystem, can be used by extensions to improve debugging
103         information and a lot more.
104 
105         So it's important what you provide there.  If you are using a single
106         module, `__name__` is always the correct value.  If you however are
107         using a package, it's usually recommended to hardcode the name of
108         your package there.
109 
110         For example if your application is defined in :file:`yourapplication/app.py`
111         you should create it with one of the two versions below::
112 
113             app = Flask('yourapplication')
114             app = Flask(__name__.split('.')[0])
115 
116         Why is that?  The application will work even with `__name__`, thanks
117         to how resources are looked up.  However it will make debugging more
118         painful.  Certain extensions can make assumptions based on the
119         import name of your application.  For example the Flask-SQLAlchemy
120         extension will look for the code in your application that triggered
121         an SQL query in debug mode.  If the import name is not properly set
122         up, that debugging information is lost.  (For example it would only
123         pick up SQL queries in `yourapplication.app` and not
124         `yourapplication.views.frontend`)
125 
126     .. versionadded:: 0.7
127        The `static_url_path`, `static_folder`, and `template_folder`
128        parameters were added.
129 
130     .. versionadded:: 0.8
131        The `instance_path` and `instance_relative_config` parameters were
132        added.
133 
134     .. versionadded:: 0.11
135        The `root_path` parameter was added.
136 
137     .. versionadded:: 1.0
138        The ``host_matching`` and ``static_host`` parameters were added.
139 
140     .. versionadded:: 1.0
141        The ``subdomain_matching`` parameter was added. Subdomain
142        matching needs to be enabled manually now. Setting
143        :data:`SERVER_NAME` does not implicitly enable it.
144 
145     :param import_name: the name of the application package
146     :param static_url_path: can be used to specify a different path for the
147                             static files on the web.  Defaults to the name
148                             of the `static_folder` folder.
149     :param static_folder: The folder with static files that is served at
150         ``static_url_path``. Relative to the application ``root_path``
151         or an absolute path. Defaults to ``'static'``.
152     :param static_host: the host to use when adding the static route.
153         Defaults to None. Required when using ``host_matching=True``
154         with a ``static_folder`` configured.
155     :param host_matching: set ``url_map.host_matching`` attribute.
156         Defaults to False.
157     :param subdomain_matching: consider the subdomain relative to
158         :data:`SERVER_NAME` when matching routes. Defaults to False.
159     :param template_folder: the folder that contains the templates that should
160                             be used by the application.  Defaults to
161                             ``'templates'`` folder in the root path of the
162                             application.
163     :param instance_path: An alternative instance path for the application.
164                           By default the folder ``'instance'`` next to the
165                           package or module is assumed to be the instance
166                           path.
167     :param instance_relative_config: if set to ``True`` relative filenames
168                                      for loading the config are assumed to
169                                      be relative to the instance path instead
170                                      of the application root.
171     :param root_path: The path to the root of the application files.
172         This should only be set manually when it can't be detected
173         automatically, such as for namespace packages.
174     """
175 
176     default_config = ImmutableDict(
177         {
178             "DEBUG": None,
179             "TESTING": False,
180             "PROPAGATE_EXCEPTIONS": None,
181             "SECRET_KEY": None,
182             "PERMANENT_SESSION_LIFETIME": timedelta(days=31),
183             "USE_X_SENDFILE": False,
184             "SERVER_NAME": None,
185             "APPLICATION_ROOT": "/",
186             "SESSION_COOKIE_NAME": "session",
187             "SESSION_COOKIE_DOMAIN": None,
188             "SESSION_COOKIE_PATH": None,
189             "SESSION_COOKIE_HTTPONLY": True,
190             "SESSION_COOKIE_SECURE": False,
191             "SESSION_COOKIE_SAMESITE": None,
192             "SESSION_REFRESH_EACH_REQUEST": True,
193             "MAX_CONTENT_LENGTH": None,
194             "SEND_FILE_MAX_AGE_DEFAULT": None,
195             "TRAP_BAD_REQUEST_ERRORS": None,
196             "TRAP_HTTP_EXCEPTIONS": False,
197             "EXPLAIN_TEMPLATE_LOADING": False,
198             "PREFERRED_URL_SCHEME": "http",
199             "TEMPLATES_AUTO_RELOAD": None,
200             "MAX_COOKIE_SIZE": 4093,
201             "PROVIDE_AUTOMATIC_OPTIONS": True,
202         }
203     )
204 
205     #: The class that is used for request objects.  See :class:`~flask.Request`
206     #: for more information.
207     request_class: type[Request] = Request
208 
209     #: The class that is used for response objects.  See
210     #: :class:`~flask.Response` for more information.
211     response_class: type[Response] = Response
212 
213     #: the session interface to use.  By default an instance of
214     #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.
215     #:
216     #: .. versionadded:: 0.8
217     session_interface: SessionInterface = SecureCookieSessionInterface()
218 
219     def __init__(
220         self,
221         import_name: str,
222         static_url_path: str | None = None,
223         static_folder: str | os.PathLike[str] | None = "static",
224         static_host: str | None = None,
225         host_matching: bool = False,
226         subdomain_matching: bool = False,
227         template_folder: str | os.PathLike[str] | None = "templates",
228         instance_path: str | None = None,
229         instance_relative_config: bool = False,
230         root_path: str | None = None,
231     ):
232         super().__init__(
233             import_name=import_name,
234             static_url_path=static_url_path,
235             static_folder=static_folder,
236             static_host=static_host,
237             host_matching=host_matching,
238             subdomain_matching=subdomain_matching,
239             template_folder=template_folder,
240             instance_path=instance_path,
241             instance_relative_config=instance_relative_config,
242             root_path=root_path,
243         )
244 
245         #: The Click command group for registering CLI commands for this
246         #: object. The commands are available from the ``flask`` command
247         #: once the application has been discovered and blueprints have
248         #: been registered.
249         self.cli = cli.AppGroup()
250 
251         # Set the name of the Click group in case someone wants to add
252         # the app's commands to another CLI tool.
253         self.cli.name = self.name
254 
255         # Add a static route using the provided static_url_path, static_host,
256         # and static_folder if there is a configured static_folder.
257         # Note we do this without checking if static_folder exists.
258         # For one, it might be created while the server is running (e.g. during
259         # development). Also, Google App Engine stores static files somewhere
260         if self.has_static_folder:
261             assert (
262                 bool(static_host) == host_matching
263             ), "Invalid static_host/host_matching combination"
264             # Use a weakref to avoid creating a reference cycle between the app
265             # and the view function (see #3761).
266             self_ref = weakref.ref(self)
267             self.add_url_rule(
268                 f"{self.static_url_path}/<path:filename>",
269                 endpoint="static",
270                 host=static_host,
271                 view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950
272             )
273 
274     def get_send_file_max_age(self, filename: str | None) -> int | None:
275         """Used by :func:`send_file` to determine the ``max_age`` cache
276         value for a given file path if it wasn't passed.
277 
278         By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
279         the configuration of :data:`~flask.current_app`. This defaults
280         to ``None``, which tells the browser to use conditional requests
281         instead of a timed cache, which is usually preferable.
282 
283         Note this is a duplicate of the same method in the Flask
284         class.
285 
286         .. versionchanged:: 2.0
287             The default configuration is ``None`` instead of 12 hours.
288 
289         .. versionadded:: 0.9
290         """
291         value = current_app.config["SEND_FILE_MAX_AGE_DEFAULT"]
292 
293         if value is None:
294             return None
295 
296         if isinstance(value, timedelta):
297             return int(value.total_seconds())
298 
299         return value  # type: ignore[no-any-return]
300 
301     def send_static_file(self, filename: str) -> Response:
302         """The view function used to serve files from
303         :attr:`static_folder`. A route is automatically registered for
304         this view at :attr:`static_url_path` if :attr:`static_folder` is
305         set.
306 
307         Note this is a duplicate of the same method in the Flask
308         class.
309 
310         .. versionadded:: 0.5
311 
312         """
313         if not self.has_static_folder:
314             raise RuntimeError("'static_folder' must be set to serve static_files.")
315 
316         # send_file only knows to call get_send_file_max_age on the app,
317         # call it here so it works for blueprints too.
318         max_age = self.get_send_file_max_age(filename)
319         return send_from_directory(
320             t.cast(str, self.static_folder), filename, max_age=max_age
321         )
322 
323     def open_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
324         """Open a resource file relative to :attr:`root_path` for
325         reading.
326 
327         For example, if the file ``schema.sql`` is next to the file
328         ``app.py`` where the ``Flask`` app is defined, it can be opened
329         with:
330 
331         .. code-block:: python
332 
333             with app.open_resource("schema.sql") as f:
334                 conn.executescript(f.read())
335 
336         :param resource: Path to the resource relative to
337             :attr:`root_path`.
338         :param mode: Open the file in this mode. Only reading is
339             supported, valid values are "r" (or "rt") and "rb".
340 
341         Note this is a duplicate of the same method in the Flask
342         class.
343 
344         """
345         if mode not in {"r", "rt", "rb"}:
346             raise ValueError("Resources can only be opened for reading.")
347 
348         return open(os.path.join(self.root_path, resource), mode)
349 
350     def open_instance_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
351         """Opens a resource from the application's instance folder
352         (:attr:`instance_path`).  Otherwise works like
353         :meth:`open_resource`.  Instance resources can also be opened for
354         writing.
355 
356         :param resource: the name of the resource.  To access resources within
357                          subfolders use forward slashes as separator.
358         :param mode: resource file opening mode, default is 'rb'.
359         """
360         return open(os.path.join(self.instance_path, resource), mode)
361 
362     def create_jinja_environment(self) -> Environment:
363         """Create the Jinja environment based on :attr:`jinja_options`
364         and the various Jinja-related methods of the app. Changing
365         :attr:`jinja_options` after this will have no effect. Also adds
366         Flask-related globals and filters to the environment.
367 
368         .. versionchanged:: 0.11
369            ``Environment.auto_reload`` set in accordance with
370            ``TEMPLATES_AUTO_RELOAD`` configuration option.
371 
372         .. versionadded:: 0.5
373         """
374         options = dict(self.jinja_options)
375 
376         if "autoescape" not in options:
377             options["autoescape"] = self.select_jinja_autoescape
378 
379         if "auto_reload" not in options:
380             auto_reload = self.config["TEMPLATES_AUTO_RELOAD"]
381 
382             if auto_reload is None:
383                 auto_reload = self.debug
384 
385             options["auto_reload"] = auto_reload
386 
387         rv = self.jinja_environment(self, **options)
388         rv.globals.update(
389             url_for=self.url_for,
390             get_flashed_messages=get_flashed_messages,
391             config=self.config,
392             # request, session and g are normally added with the
393             # context processor for efficiency reasons but for imported
394             # templates we also want the proxies in there.
395             request=request,
396             session=session,
397             g=g,
398         )
399         rv.policies["json.dumps_function"] = self.json.dumps
400         return rv
401 
402     def create_url_adapter(self, request: Request | None) -> MapAdapter | None:
403         """Creates a URL adapter for the given request. The URL adapter
404         is created at a point where the request context is not yet set
405         up so the request is passed explicitly.
406 
407         .. versionadded:: 0.6
408 
409         .. versionchanged:: 0.9
410            This can now also be called without a request object when the
411            URL adapter is created for the application context.
412 
413         .. versionchanged:: 1.0
414             :data:`SERVER_NAME` no longer implicitly enables subdomain
415             matching. Use :attr:`subdomain_matching` instead.
416         """
417         if request is not None:
418             # If subdomain matching is disabled (the default), use the
419             # default subdomain in all cases. This should be the default
420             # in Werkzeug but it currently does not have that feature.
421             if not self.subdomain_matching:
422                 subdomain = self.url_map.default_subdomain or None
423             else:
424                 subdomain = None
425 
426             return self.url_map.bind_to_environ(
427                 request.environ,
428                 server_name=self.config["SERVER_NAME"],
429                 subdomain=subdomain,
430             )
431         # We need at the very least the server name to be set for this
432         # to work.
433         if self.config["SERVER_NAME"] is not None:
434             return self.url_map.bind(
435                 self.config["SERVER_NAME"],
436                 script_name=self.config["APPLICATION_ROOT"],
437                 url_scheme=self.config["PREFERRED_URL_SCHEME"],
438             )
439 
440         return None
441 
442     def raise_routing_exception(self, request: Request) -> t.NoReturn:
443         """Intercept routing exceptions and possibly do something else.
444 
445         In debug mode, intercept a routing redirect and replace it with
446         an error if the body will be discarded.
447 
448         With modern Werkzeug this shouldn't occur, since it now uses a
449         308 status which tells the browser to resend the method and
450         body.
451 
452         .. versionchanged:: 2.1
453             Don't intercept 307 and 308 redirects.
454 
455         :meta private:
456         :internal:
457         """
458         if (
459             not self.debug
460             or not isinstance(request.routing_exception, RequestRedirect)
461             or request.routing_exception.code in {307, 308}
462             or request.method in {"GET", "HEAD", "OPTIONS"}
463         ):
464             raise request.routing_exception  # type: ignore[misc]
465 
466         from .debughelpers import FormDataRoutingRedirect
467 
468         raise FormDataRoutingRedirect(request)
469 
470     def update_template_context(self, context: dict[str, t.Any]) -> None:
471         """Update the template context with some commonly used variables.
472         This injects request, session, config and g into the template
473         context as well as everything template context processors want
474         to inject.  Note that the as of Flask 0.6, the original values
475         in the context will not be overridden if a context processor
476         decides to return a value with the same key.
477 
478         :param context: the context as a dictionary that is updated in place
479                         to add extra variables.
480         """
481         names: t.Iterable[str | None] = (None,)
482 
483         # A template may be rendered outside a request context.
484         if request:
485             names = chain(names, reversed(request.blueprints))
486 
487         # The values passed to render_template take precedence. Keep a
488         # copy to re-apply after all context functions.
489         orig_ctx = context.copy()
490 
491         for name in names:
492             if name in self.template_context_processors:
493                 for func in self.template_context_processors[name]:
494                     context.update(self.ensure_sync(func)())
495 
496         context.update(orig_ctx)
497 
498     def make_shell_context(self) -> dict[str, t.Any]:
499         """Returns the shell context for an interactive shell for this
500         application.  This runs all the registered shell context
501         processors.
502 
503         .. versionadded:: 0.11
504         """
505         rv = {"app": self, "g": g}
506         for processor in self.shell_context_processors:
507             rv.update(processor())
508         return rv
509 
510     def run(
511         self,
512         host: str | None = None,
513         port: int | None = None,
514         debug: bool | None = None,
515         load_dotenv: bool = True,
516         **options: t.Any,
517     ) -> None:
518         """Runs the application on a local development server.
519 
520         Do not use ``run()`` in a production setting. It is not intended to
521         meet security and performance requirements for a production server.
522         Instead, see :doc:`/deploying/index` for WSGI server recommendations.
523 
524         If the :attr:`debug` flag is set the server will automatically reload
525         for code changes and show a debugger in case an exception happened.
526 
527         If you want to run the application in debug mode, but disable the
528         code execution on the interactive debugger, you can pass
529         ``use_evalex=False`` as parameter.  This will keep the debugger's
530         traceback screen active, but disable code execution.
531 
532         It is not recommended to use this function for development with
533         automatic reloading as this is badly supported.  Instead you should
534         be using the :command:`flask` command line script's ``run`` support.
535 
536         .. admonition:: Keep in Mind
537 
538            Flask will suppress any server error with a generic error page
539            unless it is in debug mode.  As such to enable just the
540            interactive debugger without the code reloading, you have to
541            invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
542            Setting ``use_debugger`` to ``True`` without being in debug mode
543            won't catch any exceptions because there won't be any to
544            catch.
545 
546         :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
547             have the server available externally as well. Defaults to
548             ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable
549             if present.
550         :param port: the port of the webserver. Defaults to ``5000`` or the
551             port defined in the ``SERVER_NAME`` config variable if present.
552         :param debug: if given, enable or disable debug mode. See
553             :attr:`debug`.
554         :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
555             files to set environment variables. Will also change the working
556             directory to the directory containing the first file found.
557         :param options: the options to be forwarded to the underlying Werkzeug
558             server. See :func:`werkzeug.serving.run_simple` for more
559             information.
560 
561         .. versionchanged:: 1.0
562             If installed, python-dotenv will be used to load environment
563             variables from :file:`.env` and :file:`.flaskenv` files.
564 
565             The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.
566 
567             Threaded mode is enabled by default.
568 
569         .. versionchanged:: 0.10
570             The default port is now picked from the ``SERVER_NAME``
571             variable.
572         """
573         # Ignore this call so that it doesn't start another server if
574         # the 'flask run' command is used.
575         if os.environ.get("FLASK_RUN_FROM_CLI") == "true":
576             if not is_running_from_reloader():
577                 click.secho(
578                     " * Ignoring a call to 'app.run()' that would block"
579                     " the current 'flask' CLI command.\n"
580                     "   Only call 'app.run()' in an 'if __name__ =="
581                     ' "__main__"\' guard.',
582                     fg="red",
583                 )
584 
585             return
586 
587         if get_load_dotenv(load_dotenv):
588             cli.load_dotenv()
589 
590             # if set, env var overrides existing value
591             if "FLASK_DEBUG" in os.environ:
592                 self.debug = get_debug_flag()
593 
594         # debug passed to method overrides all other sources
595         if debug is not None:
596             self.debug = bool(debug)
597 
598         server_name = self.config.get("SERVER_NAME")
599         sn_host = sn_port = None
600 
601         if server_name:
602             sn_host, _, sn_port = server_name.partition(":")
603 
604         if not host:
605             if sn_host:
606                 host = sn_host
607             else:
608                 host = "127.0.0.1"
609 
610         if port or port == 0:
611             port = int(port)
612         elif sn_port:
613             port = int(sn_port)
614         else:
615             port = 5000
616 
617         options.setdefault("use_reloader", self.debug)
618         options.setdefault("use_debugger", self.debug)
619         options.setdefault("threaded", True)
620 
621         cli.show_server_banner(self.debug, self.name)
622 
623         from werkzeug.serving import run_simple
624 
625         try:
626             run_simple(t.cast(str, host), port, self, **options)
627         finally:
628             # reset the first request information if the development server
629             # reset normally.  This makes it possible to restart the server
630             # without reloader and that stuff from an interactive shell.
631             self._got_first_request = False
632 
633     def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> FlaskClient:
634         """Creates a test client for this application.  For information
635         about unit testing head over to :doc:`/testing`.
636 
637         Note that if you are testing for assertions or exceptions in your
638         application code, you must set ``app.testing = True`` in order for the
639         exceptions to propagate to the test client.  Otherwise, the exception
640         will be handled by the application (not visible to the test client) and
641         the only indication of an AssertionError or other exception will be a
642         500 status code response to the test client.  See the :attr:`testing`
643         attribute.  For example::
644 
645             app.testing = True
646             client = app.test_client()
647 
648         The test client can be used in a ``with`` block to defer the closing down
649         of the context until the end of the ``with`` block.  This is useful if
650         you want to access the context locals for testing::
651 
652             with app.test_client() as c:
653                 rv = c.get('/?vodka=42')
654                 assert request.args['vodka'] == '42'
655 
656         Additionally, you may pass optional keyword arguments that will then
657         be passed to the application's :attr:`test_client_class` constructor.
658         For example::
659 
660             from flask.testing import FlaskClient
661 
662             class CustomClient(FlaskClient):
663                 def __init__(self, *args, **kwargs):
664                     self._authentication = kwargs.pop("authentication")
665                     super(CustomClient,self).__init__( *args, **kwargs)
666 
667             app.test_client_class = CustomClient
668             client = app.test_client(authentication='Basic ....')
669 
670         See :class:`~flask.testing.FlaskClient` for more information.
671 
672         .. versionchanged:: 0.4
673            added support for ``with`` block usage for the client.
674 
675         .. versionadded:: 0.7
676            The `use_cookies` parameter was added as well as the ability
677            to override the client to be used by setting the
678            :attr:`test_client_class` attribute.
679 
680         .. versionchanged:: 0.11
681            Added `**kwargs` to support passing additional keyword arguments to
682            the constructor of :attr:`test_client_class`.
683         """
684         cls = self.test_client_class
685         if cls is None:
686             from .testing import FlaskClient as cls
687         return cls(  # type: ignore
688             self, self.response_class, use_cookies=use_cookies, **kwargs
689         )
690 
691     def test_cli_runner(self, **kwargs: t.Any) -> FlaskCliRunner:
692         """Create a CLI runner for testing CLI commands.
693         See :ref:`testing-cli`.
694 
695         Returns an instance of :attr:`test_cli_runner_class`, by default
696         :class:`~flask.testing.FlaskCliRunner`. The Flask app object is
697         passed as the first argument.
698 
699         .. versionadded:: 1.0
700         """
701         cls = self.test_cli_runner_class
702 
703         if cls is None:
704             from .testing import FlaskCliRunner as cls
705 
706         return cls(self, **kwargs)  # type: ignore
707 
708     def handle_http_exception(
709         self, e: HTTPException
710     ) -> HTTPException | ft.ResponseReturnValue:
711         """Handles an HTTP exception.  By default this will invoke the
712         registered error handlers and fall back to returning the
713         exception as response.
714 
715         .. versionchanged:: 1.0.3
716             ``RoutingException``, used internally for actions such as
717              slash redirects during routing, is not passed to error
718              handlers.
719 
720         .. versionchanged:: 1.0
721             Exceptions are looked up by code *and* by MRO, so
722             ``HTTPException`` subclasses can be handled with a catch-all
723             handler for the base ``HTTPException``.
724 
725         .. versionadded:: 0.3
726         """
727         # Proxy exceptions don't have error codes.  We want to always return
728         # those unchanged as errors
729         if e.code is None:
730             return e
731 
732         # RoutingExceptions are used internally to trigger routing
733         # actions, such as slash redirects raising RequestRedirect. They
734         # are not raised or handled in user code.
735         if isinstance(e, RoutingException):
736             return e
737 
738         handler = self._find_error_handler(e, request.blueprints)
739         if handler is None:
740             return e
741         return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]
742 
743     def handle_user_exception(
744         self, e: Exception
745     ) -> HTTPException | ft.ResponseReturnValue:
746         """This method is called whenever an exception occurs that
747         should be handled. A special case is :class:`~werkzeug
748         .exceptions.HTTPException` which is forwarded to the
749         :meth:`handle_http_exception` method. This function will either
750         return a response value or reraise the exception with the same
751         traceback.
752 
753         .. versionchanged:: 1.0
754             Key errors raised from request data like ``form`` show the
755             bad key in debug mode rather than a generic bad request
756             message.
757 
758         .. versionadded:: 0.7
759         """
760         if isinstance(e, BadRequestKeyError) and (
761             self.debug or self.config["TRAP_BAD_REQUEST_ERRORS"]
762         ):
763             e.show_exception = True
764 
765         if isinstance(e, HTTPException) and not self.trap_http_exception(e):
766             return self.handle_http_exception(e)
767 
768         handler = self._find_error_handler(e, request.blueprints)
769 
770         if handler is None:
771             raise
772 
773         return self.ensure_sync(handler)(e)  # type: ignore[no-any-return]
774 
775     def handle_exception(self, e: Exception) -> Response:
776         """Handle an exception that did not have an error handler
777         associated with it, or that was raised from an error handler.
778         This always causes a 500 ``InternalServerError``.
779 
780         Always sends the :data:`got_request_exception` signal.
781 
782         If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug
783         mode, the error will be re-raised so that the debugger can
784         display it. Otherwise, the original exception is logged, and
785         an :exc:`~werkzeug.exceptions.InternalServerError` is returned.
786 
787         If an error handler is registered for ``InternalServerError`` or
788         ``500``, it will be used. For consistency, the handler will
789         always receive the ``InternalServerError``. The original
790         unhandled exception is available as ``e.original_exception``.
791 
792         .. versionchanged:: 1.1.0
793             Always passes the ``InternalServerError`` instance to the
794             handler, setting ``original_exception`` to the unhandled
795             error.
796 
797         .. versionchanged:: 1.1.0
798             ``after_request`` functions and other finalization is done
799             even for the default 500 response when there is no handler.
800 
801         .. versionadded:: 0.3
802         """
803         exc_info = sys.exc_info()
804         got_request_exception.send(self, _async_wrapper=self.ensure_sync, exception=e)
805         propagate = self.config["PROPAGATE_EXCEPTIONS"]
806 
807         if propagate is None:
808             propagate = self.testing or self.debug
809 
810         if propagate:
811             # Re-raise if called with an active exception, otherwise
812             # raise the passed in exception.
813             if exc_info[1] is e:
814                 raise
815 
816             raise e
817 
818         self.log_exception(exc_info)
819         server_error: InternalServerError | ft.ResponseReturnValue
820         server_error = InternalServerError(original_exception=e)
821         handler = self._find_error_handler(server_error, request.blueprints)
822 
823         if handler is not None:
824             server_error = self.ensure_sync(handler)(server_error)
825 
826         return self.finalize_request(server_error, from_error_handler=True)
827 
828     def log_exception(
829         self,
830         exc_info: (tuple[type, BaseException, TracebackType] | tuple[None, None, None]),
831     ) -> None:
832         """Logs an exception.  This is called by :meth:`handle_exception`
833         if debugging is disabled and right before the handler is called.
834         The default implementation logs the exception as error on the
835         :attr:`logger`.
836 
837         .. versionadded:: 0.8
838         """
839         self.logger.error(
840             f"Exception on {request.path} [{request.method}]", exc_info=exc_info
841         )
842 
843     def dispatch_request(self) -> ft.ResponseReturnValue:
844         """Does the request dispatching.  Matches the URL and returns the
845         return value of the view or error handler.  This does not have to
846         be a response object.  In order to convert the return value to a
847         proper response object, call :func:`make_response`.
848 
849         .. versionchanged:: 0.7
850            This no longer does the exception handling, this code was
851            moved to the new :meth:`full_dispatch_request`.
852         """
853         req = request_ctx.request
854         if req.routing_exception is not None:
855             self.raise_routing_exception(req)
856         rule: Rule = req.url_rule  # type: ignore[assignment]
857         # if we provide automatic options for this URL and the
858         # request came with the OPTIONS method, reply automatically
859         if (
860             getattr(rule, "provide_automatic_options", False)
861             and req.method == "OPTIONS"
862         ):
863             return self.make_default_options_response()
864         # otherwise dispatch to the handler for that endpoint
865         view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]
866         return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
867 
868     def full_dispatch_request(self) -> Response:
869         """Dispatches the request and on top of that performs request
870         pre and postprocessing as well as HTTP exception catching and
871         error handling.
872 
873         .. versionadded:: 0.7
874         """
875         self._got_first_request = True
876 
877         try:
878             request_started.send(self, _async_wrapper=self.ensure_sync)
879             rv = self.preprocess_request()
880             if rv is None:
881                 rv = self.dispatch_request()
882         except Exception as e:
883             rv = self.handle_user_exception(e)
884         return self.finalize_request(rv)
885 
886     def finalize_request(
887         self,
888         rv: ft.ResponseReturnValue | HTTPException,
889         from_error_handler: bool = False,
890     ) -> Response:
891         """Given the return value from a view function this finalizes
892         the request by converting it into a response and invoking the
893         postprocessing functions.  This is invoked for both normal
894         request dispatching as well as error handlers.
895 
896         Because this means that it might be called as a result of a
897         failure a special safe mode is available which can be enabled
898         with the `from_error_handler` flag.  If enabled, failures in
899         response processing will be logged and otherwise ignored.
900 
901         :internal:
902         """
903         response = self.make_response(rv)
904         try:
905             response = self.process_response(response)
906             request_finished.send(
907                 self, _async_wrapper=self.ensure_sync, response=response
908             )
909         except Exception:
910             if not from_error_handler:
911                 raise
912             self.logger.exception(
913                 "Request finalizing failed with an error while handling an error"
914             )
915         return response
916 
917     def make_default_options_response(self) -> Response:
918         """This method is called to create the default ``OPTIONS`` response.
919         This can be changed through subclassing to change the default
920         behavior of ``OPTIONS`` responses.
921 
922         .. versionadded:: 0.7
923         """
924         adapter = request_ctx.url_adapter
925         methods = adapter.allowed_methods()  # type: ignore[union-attr]
926         rv = self.response_class()
927         rv.allow.update(methods)
928         return rv
929 
930     def ensure_sync(self, func: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:
931         """Ensure that the function is synchronous for WSGI workers.
932         Plain ``def`` functions are returned as-is. ``async def``
933         functions are wrapped to run and wait for the response.
934 
935         Override this method to change how the app runs async views.
936 
937         .. versionadded:: 2.0
938         """
939         if iscoroutinefunction(func):
940             return self.async_to_sync(func)
941 
942         return func
943 
944     def async_to_sync(
945         self, func: t.Callable[..., t.Coroutine[t.Any, t.Any, t.Any]]
946     ) -> t.Callable[..., t.Any]:
947         """Return a sync function that will run the coroutine function.
948 
949         .. code-block:: python
950 
951             result = app.async_to_sync(func)(*args, **kwargs)
952 
953         Override this method to change how the app converts async code
954         to be synchronously callable.
955 
956         .. versionadded:: 2.0
957         """
958         try:
959             from asgiref.sync import async_to_sync as asgiref_async_to_sync
960         except ImportError:
961             raise RuntimeError(
962                 "Install Flask with the 'async' extra in order to use async views."
963             ) from None
964 
965         return asgiref_async_to_sync(func)
966 
967     def url_for(
968         self,
969         /,
970         endpoint: str,
971         *,
972         _anchor: str | None = None,
973         _method: str | None = None,
974         _scheme: str | None = None,
975         _external: bool | None = None,
976         **values: t.Any,
977     ) -> str:
978         """Generate a URL to the given endpoint with the given values.
979 
980         This is called by :func:`flask.url_for`, and can be called
981         directly as well.
982 
983         An *endpoint* is the name of a URL rule, usually added with
984         :meth:`@app.route() <route>`, and usually the same name as the
985         view function. A route defined in a :class:`~flask.Blueprint`
986         will prepend the blueprint's name separated by a ``.`` to the
987         endpoint.
988 
989         In some cases, such as email messages, you want URLs to include
990         the scheme and domain, like ``https://example.com/hello``. When
991         not in an active request, URLs will be external by default, but
992         this requires setting :data:`SERVER_NAME` so Flask knows what
993         domain to use. :data:`APPLICATION_ROOT` and
994         :data:`PREFERRED_URL_SCHEME` should also be configured as
995         needed. This config is only used when not in an active request.
996 
997         Functions can be decorated with :meth:`url_defaults` to modify
998         keyword arguments before the URL is built.
999 
1000         If building fails for some reason, such as an unknown endpoint
1001         or incorrect values, the app's :meth:`handle_url_build_error`
1002         method is called. If that returns a string, that is returned,
1003         otherwise a :exc:`~werkzeug.routing.BuildError` is raised.
1004 
1005         :param endpoint: The endpoint name associated with the URL to
1006             generate. If this starts with a ``.``, the current blueprint
1007             name (if any) will be used.
1008         :param _anchor: If given, append this as ``#anchor`` to the URL.
1009         :param _method: If given, generate the URL associated with this
1010             method for the endpoint.
1011         :param _scheme: If given, the URL will have this scheme if it
1012             is external.
1013         :param _external: If given, prefer the URL to be internal
1014             (False) or require it to be external (True). External URLs
1015             include the scheme and domain. When not in an active
1016             request, URLs are external by default.
1017         :param values: Values to use for the variable parts of the URL
1018             rule. Unknown keys are appended as query string arguments,
1019             like ``?a=b&c=d``.
1020 
1021         .. versionadded:: 2.2
1022             Moved from ``flask.url_for``, which calls this method.
1023         """
1024         req_ctx = _cv_request.get(None)
1025 
1026         if req_ctx is not None:
1027             url_adapter = req_ctx.url_adapter
1028             blueprint_name = req_ctx.request.blueprint
1029 
1030             # If the endpoint starts with "." and the request matches a
1031             # blueprint, the endpoint is relative to the blueprint.
1032             if endpoint[:1] == ".":
1033                 if blueprint_name is not None:
1034                     endpoint = f"{blueprint_name}{endpoint}"
1035                 else:
1036                     endpoint = endpoint[1:]
1037 
1038             # When in a request, generate a URL without scheme and
1039             # domain by default, unless a scheme is given.
1040             if _external is None:
1041                 _external = _scheme is not None
1042         else:
1043             app_ctx = _cv_app.get(None)
1044 
1045             # If called by helpers.url_for, an app context is active,
1046             # use its url_adapter. Otherwise, app.url_for was called
1047             # directly, build an adapter.
1048             if app_ctx is not None:
1049                 url_adapter = app_ctx.url_adapter
1050             else:
1051                 url_adapter = self.create_url_adapter(None)
1052 
1053             if url_adapter is None:
1054                 raise RuntimeError(
1055                     "Unable to build URLs outside an active request"
1056                     " without 'SERVER_NAME' configured. Also configure"
1057                     " 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as"
1058                     " needed."
1059                 )
1060 
1061             # When outside a request, generate a URL with scheme and
1062             # domain by default.
1063             if _external is None:
1064                 _external = True
1065 
1066         # It is an error to set _scheme when _external=False, in order
1067         # to avoid accidental insecure URLs.
1068         if _scheme is not None and not _external:
1069             raise ValueError("When specifying '_scheme', '_external' must be True.")
1070 
1071         self.inject_url_defaults(endpoint, values)
1072 
1073         try:
1074             rv = url_adapter.build(  # type: ignore[union-attr]
1075                 endpoint,
1076                 values,
1077                 method=_method,
1078                 url_scheme=_scheme,
1079                 force_external=_external,
1080             )
1081         except BuildError as error:
1082             values.update(
1083                 _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external
1084             )
1085             return self.handle_url_build_error(error, endpoint, values)
1086 
1087         if _anchor is not None:
1088             _anchor = _url_quote(_anchor, safe="%!#$&'()*+,/:;=?@")
1089             rv = f"{rv}#{_anchor}"
1090 
1091         return rv
1092 
1093     def make_response(self, rv: ft.ResponseReturnValue) -> Response:
1094         """Convert the return value from a view function to an instance of
1095         :attr:`response_class`.
1096 
1097         :param rv: the return value from the view function. The view function
1098             must return a response. Returning ``None``, or the view ending
1099             without returning, is not allowed. The following types are allowed
1100             for ``view_rv``:
1101 
1102             ``str``
1103                 A response object is created with the string encoded to UTF-8
1104                 as the body.
1105 
1106             ``bytes``
1107                 A response object is created with the bytes as the body.
1108 
1109             ``dict``
1110                 A dictionary that will be jsonify'd before being returned.
1111 
1112             ``list``
1113                 A list that will be jsonify'd before being returned.
1114 
1115             ``generator`` or ``iterator``
1116                 A generator that returns ``str`` or ``bytes`` to be
1117                 streamed as the response.
1118 
1119             ``tuple``
1120                 Either ``(body, status, headers)``, ``(body, status)``, or
1121                 ``(body, headers)``, where ``body`` is any of the other types
1122                 allowed here, ``status`` is a string or an integer, and
1123                 ``headers`` is a dictionary or a list of ``(key, value)``
1124                 tuples. If ``body`` is a :attr:`response_class` instance,
1125                 ``status`` overwrites the exiting value and ``headers`` are
1126                 extended.
1127 
1128             :attr:`response_class`
1129                 The object is returned unchanged.
1130 
1131             other :class:`~werkzeug.wrappers.Response` class
1132                 The object is coerced to :attr:`response_class`.
1133 
1134             :func:`callable`
1135                 The function is called as a WSGI application. The result is
1136                 used to create a response object.
1137 
1138         .. versionchanged:: 2.2
1139             A generator will be converted to a streaming response.
1140             A list will be converted to a JSON response.
1141 
1142         .. versionchanged:: 1.1
1143             A dict will be converted to a JSON response.
1144 
1145         .. versionchanged:: 0.9
1146            Previously a tuple was interpreted as the arguments for the
1147            response object.
1148         """
1149 
1150         status = headers = None
1151 
1152         # unpack tuple returns
1153         if isinstance(rv, tuple):
1154             len_rv = len(rv)
1155 
1156             # a 3-tuple is unpacked directly
1157             if len_rv == 3:
1158                 rv, status, headers = rv  # type: ignore[misc]
1159             # decide if a 2-tuple has status or headers
1160             elif len_rv == 2:
1161                 if isinstance(rv[1], (Headers, dict, tuple, list)):
1162                     rv, headers = rv
1163                 else:
1164                     rv, status = rv  # type: ignore[assignment,misc]
1165             # other sized tuples are not allowed
1166             else:
1167                 raise TypeError(
1168                     "The view function did not return a valid response tuple."
1169                     " The tuple must have the form (body, status, headers),"
1170                     " (body, status), or (body, headers)."
1171                 )
1172 
1173         # the body must not be None
1174         if rv is None:
1175             raise TypeError(
1176                 f"The view function for {request.endpoint!r} did not"
1177                 " return a valid response. The function either returned"
1178                 " None or ended without a return statement."
1179             )
1180 
1181         # make sure the body is an instance of the response class
1182         if not isinstance(rv, self.response_class):
1183             if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, cabc.Iterator):
1184                 # let the response class set the status and headers instead of
1185                 # waiting to do it manually, so that the class can handle any
1186                 # special logic
1187                 rv = self.response_class(
1188                     rv,
1189                     status=status,
1190                     headers=headers,  # type: ignore[arg-type]
1191                 )
1192                 status = headers = None
1193             elif isinstance(rv, (dict, list)):
1194                 rv = self.json.response(rv)
1195             elif isinstance(rv, BaseResponse) or callable(rv):
1196                 # evaluate a WSGI callable, or coerce a different response
1197                 # class to the correct type
1198                 try:
1199                     rv = self.response_class.force_type(
1200                         rv,  # type: ignore[arg-type]
1201                         request.environ,
1202                     )
1203                 except TypeError as e:
1204                     raise TypeError(
1205                         f"{e}\nThe view function did not return a valid"
1206                         " response. The return type must be a string,"
1207                         " dict, list, tuple with headers or status,"
1208                         " Response instance, or WSGI callable, but it"
1209                         f" was a {type(rv).__name__}."
1210                     ).with_traceback(sys.exc_info()[2]) from None
1211             else:
1212                 raise TypeError(
1213                     "The view function did not return a valid"
1214                     " response. The return type must be a string,"
1215                     " dict, list, tuple with headers or status,"
1216                     " Response instance, or WSGI callable, but it was a"
1217                     f" {type(rv).__name__}."
1218                 )
1219 
1220         rv = t.cast(Response, rv)
1221         # prefer the status if it was provided
1222         if status is not None:
1223             if isinstance(status, (str, bytes, bytearray)):
1224                 rv.status = status
1225             else:
1226                 rv.status_code = status
1227 
1228         # extend existing headers with provided headers
1229         if headers:
1230             rv.headers.update(headers)  # type: ignore[arg-type]
1231 
1232         return rv
1233 
1234     def preprocess_request(self) -> ft.ResponseReturnValue | None:
1235         """Called before the request is dispatched. Calls
1236         :attr:`url_value_preprocessors` registered with the app and the
1237         current blueprint (if any). Then calls :attr:`before_request_funcs`
1238         registered with the app and the blueprint.
1239 
1240         If any :meth:`before_request` handler returns a non-None value, the
1241         value is handled as if it was the return value from the view, and
1242         further request handling is stopped.
1243         """
1244         names = (None, *reversed(request.blueprints))
1245 
1246         for name in names:
1247             if name in self.url_value_preprocessors:
1248                 for url_func in self.url_value_preprocessors[name]:
1249                     url_func(request.endpoint, request.view_args)
1250 
1251         for name in names:
1252             if name in self.before_request_funcs:
1253                 for before_func in self.before_request_funcs[name]:
1254                     rv = self.ensure_sync(before_func)()
1255 
1256                     if rv is not None:
1257                         return rv  # type: ignore[no-any-return]
1258 
1259         return None
1260 
1261     def process_response(self, response: Response) -> Response:
1262         """Can be overridden in order to modify the response object
1263         before it's sent to the WSGI server.  By default this will
1264         call all the :meth:`after_request` decorated functions.
1265 
1266         .. versionchanged:: 0.5
1267            As of Flask 0.5 the functions registered for after request
1268            execution are called in reverse order of registration.
1269 
1270         :param response: a :attr:`response_class` object.
1271         :return: a new response object or the same, has to be an
1272                  instance of :attr:`response_class`.
1273         """
1274         ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]
1275 
1276         for func in ctx._after_request_functions:
1277             response = self.ensure_sync(func)(response)
1278 
1279         for name in chain(request.blueprints, (None,)):
1280             if name in self.after_request_funcs:
1281                 for func in reversed(self.after_request_funcs[name]):
1282                     response = self.ensure_sync(func)(response)
1283 
1284         if not self.session_interface.is_null_session(ctx.session):
1285             self.session_interface.save_session(self, ctx.session, response)
1286 
1287         return response
1288 
1289     def do_teardown_request(
1290         self,
1291         exc: BaseException | None = _sentinel,  # type: ignore[assignment]
1292     ) -> None:
1293         """Called after the request is dispatched and the response is
1294         returned, right before the request context is popped.
1295 
1296         This calls all functions decorated with
1297         :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`
1298         if a blueprint handled the request. Finally, the
1299         :data:`request_tearing_down` signal is sent.
1300 
1301         This is called by
1302         :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,
1303         which may be delayed during testing to maintain access to
1304         resources.
1305 
1306         :param exc: An unhandled exception raised while dispatching the
1307             request. Detected from the current exception information if
1308             not passed. Passed to each teardown function.
1309 
1310         .. versionchanged:: 0.9
1311             Added the ``exc`` argument.
1312         """
1313         if exc is _sentinel:
1314             exc = sys.exc_info()[1]
1315 
1316         for name in chain(request.blueprints, (None,)):
1317             if name in self.teardown_request_funcs:
1318                 for func in reversed(self.teardown_request_funcs[name]):
1319                     self.ensure_sync(func)(exc)
1320 
1321         request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)
1322 
1323     def do_teardown_appcontext(
1324         self,
1325         exc: BaseException | None = _sentinel,  # type: ignore[assignment]
1326     ) -> None:
1327         """Called right before the application context is popped.
1328 
1329         When handling a request, the application context is popped
1330         after the request context. See :meth:`do_teardown_request`.
1331 
1332         This calls all functions decorated with
1333         :meth:`teardown_appcontext`. Then the
1334         :data:`appcontext_tearing_down` signal is sent.
1335 
1336         This is called by
1337         :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.
1338 
1339         .. versionadded:: 0.9
1340         """
1341         if exc is _sentinel:
1342             exc = sys.exc_info()[1]
1343 
1344         for func in reversed(self.teardown_appcontext_funcs):
1345             self.ensure_sync(func)(exc)
1346 
1347         appcontext_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)
1348 
1349     def app_context(self) -> AppContext:
1350         """Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
1351         block to push the context, which will make :data:`current_app`
1352         point at this application.
1353 
1354         An application context is automatically pushed by
1355         :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`
1356         when handling a request, and when running a CLI command. Use
1357         this to manually create a context outside of these situations.
1358 
1359         ::
1360 
1361             with app.app_context():
1362                 init_db()
1363 
1364         See :doc:`/appcontext`.
1365 
1366         .. versionadded:: 0.9
1367         """
1368         return AppContext(self)
1369 
1370     def request_context(self, environ: WSGIEnvironment) -> RequestContext:
1371         """Create a :class:`~flask.ctx.RequestContext` representing a
1372         WSGI environment. Use a ``with`` block to push the context,
1373         which will make :data:`request` point at this request.
1374 
1375         See :doc:`/reqcontext`.
1376 
1377         Typically you should not call this from your own code. A request
1378         context is automatically pushed by the :meth:`wsgi_app` when
1379         handling a request. Use :meth:`test_request_context` to create
1380         an environment and context instead of this method.
1381 
1382         :param environ: a WSGI environment
1383         """
1384         return RequestContext(self, environ)
1385 
1386     def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:
1387         """Create a :class:`~flask.ctx.RequestContext` for a WSGI
1388         environment created from the given values. This is mostly useful
1389         during testing, where you may want to run a function that uses
1390         request data without dispatching a full request.
1391 
1392         See :doc:`/reqcontext`.
1393 
1394         Use a ``with`` block to push the context, which will make
1395         :data:`request` point at the request for the created
1396         environment. ::
1397 
1398             with app.test_request_context(...):
1399                 generate_report()
1400 
1401         When using the shell, it may be easier to push and pop the
1402         context manually to avoid indentation. ::
1403 
1404             ctx = app.test_request_context(...)
1405             ctx.push()
1406             ...
1407             ctx.pop()
1408 
1409         Takes the same arguments as Werkzeug's
1410         :class:`~werkzeug.test.EnvironBuilder`, with some defaults from
1411         the application. See the linked Werkzeug docs for most of the
1412         available arguments. Flask-specific behavior is listed here.
1413 
1414         :param path: URL path being requested.
1415         :param base_url: Base URL where the app is being served, which
1416             ``path`` is relative to. If not given, built from
1417             :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
1418             :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
1419         :param subdomain: Subdomain name to append to
1420             :data:`SERVER_NAME`.
1421         :param url_scheme: Scheme to use instead of
1422             :data:`PREFERRED_URL_SCHEME`.
1423         :param data: The request body, either as a string or a dict of
1424             form keys and values.
1425         :param json: If given, this is serialized as JSON and passed as
1426             ``data``. Also defaults ``content_type`` to
1427             ``application/json``.
1428         :param args: other positional arguments passed to
1429             :class:`~werkzeug.test.EnvironBuilder`.
1430         :param kwargs: other keyword arguments passed to
1431             :class:`~werkzeug.test.EnvironBuilder`.
1432         """
1433         from .testing import EnvironBuilder
1434 
1435         builder = EnvironBuilder(self, *args, **kwargs)
1436 
1437         try:
1438             return self.request_context(builder.get_environ())
1439         finally:
1440             builder.close()
1441 
1442     def wsgi_app(
1443         self, environ: WSGIEnvironment, start_response: StartResponse
1444     ) -> cabc.Iterable[bytes]:
1445         """The actual WSGI application. This is not implemented in
1446         :meth:`__call__` so that middlewares can be applied without
1447         losing a reference to the app object. Instead of doing this::
1448 
1449             app = MyMiddleware(app)
1450 
1451         It's a better idea to do this instead::
1452 
1453             app.wsgi_app = MyMiddleware(app.wsgi_app)
1454 
1455         Then you still have the original application object around and
1456         can continue to call methods on it.
1457 
1458         .. versionchanged:: 0.7
1459             Teardown events for the request and app contexts are called
1460             even if an unhandled error occurs. Other events may not be
1461             called depending on when an error occurs during dispatch.
1462             See :ref:`callbacks-and-errors`.
1463 
1464         :param environ: A WSGI environment.
1465         :param start_response: A callable accepting a status code,
1466             a list of headers, and an optional exception context to
1467             start the response.
1468         """
1469         ctx = self.request_context(environ)
1470         error: BaseException | None = None
1471         try:
1472             try:
1473                 ctx.push()
1474                 response = self.full_dispatch_request()
1475             except Exception as e:
1476                 error = e
1477                 response = self.handle_exception(e)
1478             except:  # noqa: B001
1479                 error = sys.exc_info()[1]
1480                 raise
1481             return response(environ, start_response)
1482         finally:
1483             if "werkzeug.debug.preserve_context" in environ:
1484                 environ["werkzeug.debug.preserve_context"](_cv_app.get())
1485                 environ["werkzeug.debug.preserve_context"](_cv_request.get())
1486 
1487             if error is not None and self.should_ignore_error(error):
1488                 error = None
1489 
1490             ctx.pop(error)
1491 
1492     def __call__(
1493         self, environ: WSGIEnvironment, start_response: StartResponse
1494     ) -> cabc.Iterable[bytes]:
1495         """The WSGI server calls the Flask application object as the
1496         WSGI application. This calls :meth:`wsgi_app`, which can be
1497         wrapped to apply middleware.
1498         """
1499         return self.wsgi_app(environ, start_response)
1500 
======================================

FILE NAME : blueprints.py =====
1 from __future__ import annotations
2 
3 import os
4 import typing as t
5 from datetime import timedelta
6 
7 from .cli import AppGroup
8 from .globals import current_app
9 from .helpers import send_from_directory
10 from .sansio.blueprints import Blueprint as SansioBlueprint
11 from .sansio.blueprints import BlueprintSetupState as BlueprintSetupState  # noqa
12 from .sansio.scaffold import _sentinel
13 
14 if t.TYPE_CHECKING:  # pragma: no cover
15     from .wrappers import Response
16 
17 
18 class Blueprint(SansioBlueprint):
19     def __init__(
20         self,
21         name: str,
22         import_name: str,
23         static_folder: str | os.PathLike[str] | None = None,
24         static_url_path: str | None = None,
25         template_folder: str | os.PathLike[str] | None = None,
26         url_prefix: str | None = None,
27         subdomain: str | None = None,
28         url_defaults: dict[str, t.Any] | None = None,
29         root_path: str | None = None,
30         cli_group: str | None = _sentinel,  # type: ignore
31     ) -> None:
32         super().__init__(
33             name,
34             import_name,
35             static_folder,
36             static_url_path,
37             template_folder,
38             url_prefix,
39             subdomain,
40             url_defaults,
41             root_path,
42             cli_group,
43         )
44 
45         #: The Click command group for registering CLI commands for this
46         #: object. The commands are available from the ``flask`` command
47         #: once the application has been discovered and blueprints have
48         #: been registered.
49         self.cli = AppGroup()
50 
51         # Set the name of the Click group in case someone wants to add
52         # the app's commands to another CLI tool.
53         self.cli.name = self.name
54 
55     def get_send_file_max_age(self, filename: str | None) -> int | None:
56         """Used by :func:`send_file` to determine the ``max_age`` cache
57         value for a given file path if it wasn't passed.
58 
59         By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
60         the configuration of :data:`~flask.current_app`. This defaults
61         to ``None``, which tells the browser to use conditional requests
62         instead of a timed cache, which is usually preferable.
63 
64         Note this is a duplicate of the same method in the Flask
65         class.
66 
67         .. versionchanged:: 2.0
68             The default configuration is ``None`` instead of 12 hours.
69 
70         .. versionadded:: 0.9
71         """
72         value = current_app.config["SEND_FILE_MAX_AGE_DEFAULT"]
73 
74         if value is None:
75             return None
76 
77         if isinstance(value, timedelta):
78             return int(value.total_seconds())
79 
80         return value  # type: ignore[no-any-return]
81 
82     def send_static_file(self, filename: str) -> Response:
83         """The view function used to serve files from
84         :attr:`static_folder`. A route is automatically registered for
85         this view at :attr:`static_url_path` if :attr:`static_folder` is
86         set.
87 
88         Note this is a duplicate of the same method in the Flask
89         class.
90 
91         .. versionadded:: 0.5
92 
93         """
94         if not self.has_static_folder:
95             raise RuntimeError("'static_folder' must be set to serve static_files.")
96 
97         # send_file only knows to call get_send_file_max_age on the app,
98         # call it here so it works for blueprints too.
99         max_age = self.get_send_file_max_age(filename)
100         return send_from_directory(
101             t.cast(str, self.static_folder), filename, max_age=max_age
102         )
103 
104     def open_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
105         """Open a resource file relative to :attr:`root_path` for
106         reading.
107 
108         For example, if the file ``schema.sql`` is next to the file
109         ``app.py`` where the ``Flask`` app is defined, it can be opened
110         with:
111 
112         .. code-block:: python
113 
114             with app.open_resource("schema.sql") as f:
115                 conn.executescript(f.read())
116 
117         :param resource: Path to the resource relative to
118             :attr:`root_path`.
119         :param mode: Open the file in this mode. Only reading is
120             supported, valid values are "r" (or "rt") and "rb".
121 
122         Note this is a duplicate of the same method in the Flask
123         class.
124 
125         """
126         if mode not in {"r", "rt", "rb"}:
127             raise ValueError("Resources can only be opened for reading.")
128 
129         return open(os.path.join(self.root_path, resource), mode)
130 
======================================

FILE NAME : cli.py =====
1 from __future__ import annotations
2 
3 import ast
4 import collections.abc as cabc
5 import importlib.metadata
6 import inspect
7 import os
8 import platform
9 import re
10 import sys
11 import traceback
12 import typing as t
13 from functools import update_wrapper
14 from operator import itemgetter
15 from types import ModuleType
16 
17 import click
18 from click.core import ParameterSource
19 from werkzeug import run_simple
20 from werkzeug.serving import is_running_from_reloader
21 from werkzeug.utils import import_string
22 
23 from .globals import current_app
24 from .helpers import get_debug_flag
25 from .helpers import get_load_dotenv
26 
27 if t.TYPE_CHECKING:
28     import ssl
29 
30     from _typeshed.wsgi import StartResponse
31     from _typeshed.wsgi import WSGIApplication
32     from _typeshed.wsgi import WSGIEnvironment
33 
34     from .app import Flask
35 
36 
37 class NoAppException(click.UsageError):
38     """Raised if an application cannot be found or loaded."""
39 
40 
41 def find_best_app(module: ModuleType) -> Flask:
42     """Given a module instance this tries to find the best possible
43     application in the module or raises an exception.
44     """
45     from . import Flask
46 
47     # Search for the most common names first.
48     for attr_name in ("app", "application"):
49         app = getattr(module, attr_name, None)
50 
51         if isinstance(app, Flask):
52             return app
53 
54     # Otherwise find the only object that is a Flask instance.
55     matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
56 
57     if len(matches) == 1:
58         return matches[0]
59     elif len(matches) > 1:
60         raise NoAppException(
61             "Detected multiple Flask applications in module"
62             f" '{module.__name__}'. Use '{module.__name__}:name'"
63             " to specify the correct one."
64         )
65 
66     # Search for app factory functions.
67     for attr_name in ("create_app", "make_app"):
68         app_factory = getattr(module, attr_name, None)
69 
70         if inspect.isfunction(app_factory):
71             try:
72                 app = app_factory()
73 
74                 if isinstance(app, Flask):
75                     return app
76             except TypeError as e:
77                 if not _called_with_wrong_args(app_factory):
78                     raise
79 
80                 raise NoAppException(
81                     f"Detected factory '{attr_name}' in module '{module.__name__}',"
82                     " but could not call it without arguments. Use"
83                     f" '{module.__name__}:{attr_name}(args)'"
84                     " to specify arguments."
85                 ) from e
86 
87     raise NoAppException(
88         "Failed to find Flask application or factory in module"
89         f" '{module.__name__}'. Use '{module.__name__}:name'"
90         " to specify one."
91     )
92 
93 
94 def _called_with_wrong_args(f: t.Callable[..., Flask]) -> bool:
95     """Check whether calling a function raised a ``TypeError`` because
96     the call failed or because something in the factory raised the
97     error.
98 
99     :param f: The function that was called.
100     :return: ``True`` if the call failed.
101     """
102     tb = sys.exc_info()[2]
103 
104     try:
105         while tb is not None:
106             if tb.tb_frame.f_code is f.__code__:
107                 # In the function, it was called successfully.
108                 return False
109 
110             tb = tb.tb_next
111 
112         # Didn't reach the function.
113         return True
114     finally:
115         # Delete tb to break a circular reference.
116         # https://docs.python.org/2/library/sys.html#sys.exc_info
117         del tb
118 
119 
120 def find_app_by_string(module: ModuleType, app_name: str) -> Flask:
121     """Check if the given string is a variable name or a function. Call
122     a function to get the app instance, or return the variable directly.
123     """
124     from . import Flask
125 
126     # Parse app_name as a single expression to determine if it's a valid
127     # attribute name or function call.
128     try:
129         expr = ast.parse(app_name.strip(), mode="eval").body
130     except SyntaxError:
131         raise NoAppException(
132             f"Failed to parse {app_name!r} as an attribute name or function call."
133         ) from None
134 
135     if isinstance(expr, ast.Name):
136         name = expr.id
137         args = []
138         kwargs = {}
139     elif isinstance(expr, ast.Call):
140         # Ensure the function name is an attribute name only.
141         if not isinstance(expr.func, ast.Name):
142             raise NoAppException(
143                 f"Function reference must be a simple name: {app_name!r}."
144             )
145 
146         name = expr.func.id
147 
148         # Parse the positional and keyword arguments as literals.
149         try:
150             args = [ast.literal_eval(arg) for arg in expr.args]
151             kwargs = {
152                 kw.arg: ast.literal_eval(kw.value)
153                 for kw in expr.keywords
154                 if kw.arg is not None
155             }
156         except ValueError:
157             # literal_eval gives cryptic error messages, show a generic
158             # message with the full expression instead.
159             raise NoAppException(
160                 f"Failed to parse arguments as literal values: {app_name!r}."
161             ) from None
162     else:
163         raise NoAppException(
164             f"Failed to parse {app_name!r} as an attribute name or function call."
165         )
166 
167     try:
168         attr = getattr(module, name)
169     except AttributeError as e:
170         raise NoAppException(
171             f"Failed to find attribute {name!r} in {module.__name__!r}."
172         ) from e
173 
174     # If the attribute is a function, call it with any args and kwargs
175     # to get the real application.
176     if inspect.isfunction(attr):
177         try:
178             app = attr(*args, **kwargs)
179         except TypeError as e:
180             if not _called_with_wrong_args(attr):
181                 raise
182 
183             raise NoAppException(
184                 f"The factory {app_name!r} in module"
185                 f" {module.__name__!r} could not be called with the"
186                 " specified arguments."
187             ) from e
188     else:
189         app = attr
190 
191     if isinstance(app, Flask):
192         return app
193 
194     raise NoAppException(
195         "A valid Flask application was not obtained from"
196         f" '{module.__name__}:{app_name}'."
197     )
198 
199 
200 def prepare_import(path: str) -> str:
201     """Given a filename this will try to calculate the python path, add it
202     to the search path and return the actual module name that is expected.
203     """
204     path = os.path.realpath(path)
205 
206     fname, ext = os.path.splitext(path)
207     if ext == ".py":
208         path = fname
209 
210     if os.path.basename(path) == "__init__":
211         path = os.path.dirname(path)
212 
213     module_name = []
214 
215     # move up until outside package structure (no __init__.py)
216     while True:
217         path, name = os.path.split(path)
218         module_name.append(name)
219 
220         if not os.path.exists(os.path.join(path, "__init__.py")):
221             break
222 
223     if sys.path[0] != path:
224         sys.path.insert(0, path)
225 
226     return ".".join(module_name[::-1])
227 
228 
229 @t.overload
230 def locate_app(
231     module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True
232 ) -> Flask: ...
233 
234 
235 @t.overload
236 def locate_app(
237     module_name: str, app_name: str | None, raise_if_not_found: t.Literal[False] = ...
238 ) -> Flask | None: ...
239 
240 
241 def locate_app(
242     module_name: str, app_name: str | None, raise_if_not_found: bool = True
243 ) -> Flask | None:
244     try:
245         __import__(module_name)
246     except ImportError:
247         # Reraise the ImportError if it occurred within the imported module.
248         # Determine this by checking whether the trace has a depth > 1.
249         if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]
250             raise NoAppException(
251                 f"While importing {module_name!r}, an ImportError was"
252                 f" raised:\n\n{traceback.format_exc()}"
253             ) from None
254         elif raise_if_not_found:
255             raise NoAppException(f"Could not import {module_name!r}.") from None
256         else:
257             return None
258 
259     module = sys.modules[module_name]
260 
261     if app_name is None:
262         return find_best_app(module)
263     else:
264         return find_app_by_string(module, app_name)
265 
266 
267 def get_version(ctx: click.Context, param: click.Parameter, value: t.Any) -> None:
268     if not value or ctx.resilient_parsing:
269         return
270 
271     flask_version = importlib.metadata.version("flask")
272     werkzeug_version = importlib.metadata.version("werkzeug")
273 
274     click.echo(
275         f"Python {platform.python_version()}\n"
276         f"Flask {flask_version}\n"
277         f"Werkzeug {werkzeug_version}",
278         color=ctx.color,
279     )
280     ctx.exit()
281 
282 
283 version_option = click.Option(
284     ["--version"],
285     help="Show the Flask version.",
286     expose_value=False,
287     callback=get_version,
288     is_flag=True,
289     is_eager=True,
290 )
291 
292 
293 class ScriptInfo:
294     """Helper object to deal with Flask applications.  This is usually not
295     necessary to interface with as it's used internally in the dispatching
296     to click.  In future versions of Flask this object will most likely play
297     a bigger role.  Typically it's created automatically by the
298     :class:`FlaskGroup` but you can also manually create it and pass it
299     onwards as click object.
300     """
301 
302     def __init__(
303         self,
304         app_import_path: str | None = None,
305         create_app: t.Callable[..., Flask] | None = None,
306         set_debug_flag: bool = True,
307     ) -> None:
308         #: Optionally the import path for the Flask application.
309         self.app_import_path = app_import_path
310         #: Optionally a function that is passed the script info to create
311         #: the instance of the application.
312         self.create_app = create_app
313         #: A dictionary with arbitrary data that can be associated with
314         #: this script info.
315         self.data: dict[t.Any, t.Any] = {}
316         self.set_debug_flag = set_debug_flag
317         self._loaded_app: Flask | None = None
318 
319     def load_app(self) -> Flask:
320         """Loads the Flask app (if not yet loaded) and returns it.  Calling
321         this multiple times will just result in the already loaded app to
322         be returned.
323         """
324         if self._loaded_app is not None:
325             return self._loaded_app
326 
327         if self.create_app is not None:
328             app: Flask | None = self.create_app()
329         else:
330             if self.app_import_path:
331                 path, name = (
332                     re.split(r":(?![\\/])", self.app_import_path, maxsplit=1) + [None]
333                 )[:2]
334                 import_name = prepare_import(path)
335                 app = locate_app(import_name, name)
336             else:
337                 for path in ("wsgi.py", "app.py"):
338                     import_name = prepare_import(path)
339                     app = locate_app(import_name, None, raise_if_not_found=False)
340 
341                     if app is not None:
342                         break
343 
344         if app is None:
345             raise NoAppException(
346                 "Could not locate a Flask application. Use the"
347                 " 'flask --app' option, 'FLASK_APP' environment"
348                 " variable, or a 'wsgi.py' or 'app.py' file in the"
349                 " current directory."
350             )
351 
352         if self.set_debug_flag:
353             # Update the app's debug flag through the descriptor so that
354             # other values repopulate as well.
355             app.debug = get_debug_flag()
356 
357         self._loaded_app = app
358         return app
359 
360 
361 pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)
362 
363 F = t.TypeVar("F", bound=t.Callable[..., t.Any])
364 
365 
366 def with_appcontext(f: F) -> F:
367     """Wraps a callback so that it's guaranteed to be executed with the
368     script's application context.
369 
370     Custom commands (and their options) registered under ``app.cli`` or
371     ``blueprint.cli`` will always have an app context available, this
372     decorator is not required in that case.
373 
374     .. versionchanged:: 2.2
375         The app context is active for subcommands as well as the
376         decorated callback. The app context is always available to
377         ``app.cli`` command and parameter callbacks.
378     """
379 
380     @click.pass_context
381     def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -> t.Any:
382         if not current_app:
383             app = ctx.ensure_object(ScriptInfo).load_app()
384             ctx.with_resource(app.app_context())
385 
386         return ctx.invoke(f, *args, **kwargs)
387 
388     return update_wrapper(decorator, f)  # type: ignore[return-value]
389 
390 
391 class AppGroup(click.Group):
392     """This works similar to a regular click :class:`~click.Group` but it
393     changes the behavior of the :meth:`command` decorator so that it
394     automatically wraps the functions in :func:`with_appcontext`.
395 
396     Not to be confused with :class:`FlaskGroup`.
397     """
398 
399     def command(  # type: ignore[override]
400         self, *args: t.Any, **kwargs: t.Any
401     ) -> t.Callable[[t.Callable[..., t.Any]], click.Command]:
402         """This works exactly like the method of the same name on a regular
403         :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
404         unless it's disabled by passing ``with_appcontext=False``.
405         """
406         wrap_for_ctx = kwargs.pop("with_appcontext", True)
407 
408         def decorator(f: t.Callable[..., t.Any]) -> click.Command:
409             if wrap_for_ctx:
410                 f = with_appcontext(f)
411             return super(AppGroup, self).command(*args, **kwargs)(f)  # type: ignore[no-any-return]
412 
413         return decorator
414 
415     def group(  # type: ignore[override]
416         self, *args: t.Any, **kwargs: t.Any
417     ) -> t.Callable[[t.Callable[..., t.Any]], click.Group]:
418         """This works exactly like the method of the same name on a regular
419         :class:`click.Group` but it defaults the group class to
420         :class:`AppGroup`.
421         """
422         kwargs.setdefault("cls", AppGroup)
423         return super().group(*args, **kwargs)  # type: ignore[no-any-return]
424 
425 
426 def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:
427     if value is None:
428         return None
429 
430     info = ctx.ensure_object(ScriptInfo)
431     info.app_import_path = value
432     return value
433 
434 
435 # This option is eager so the app will be available if --help is given.
436 # --help is also eager, so --app must be before it in the param list.
437 # no_args_is_help bypasses eager processing, so this option must be
438 # processed manually in that case to ensure FLASK_APP gets picked up.
439 _app_option = click.Option(
440     ["-A", "--app"],
441     metavar="IMPORT",
442     help=(
443         "The Flask application or factory function to load, in the form 'module:name'."
444         " Module can be a dotted import or file path. Name is not required if it is"
445         " 'app', 'application', 'create_app', or 'make_app', and can be 'name(args)' to"
446         " pass arguments."
447     ),
448     is_eager=True,
449     expose_value=False,
450     callback=_set_app,
451 )
452 
453 
454 def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:
455     # If the flag isn't provided, it will default to False. Don't use
456     # that, let debug be set by env in that case.
457     source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]
458 
459     if source is not None and source in (
460         ParameterSource.DEFAULT,
461         ParameterSource.DEFAULT_MAP,
462     ):
463         return None
464 
465     # Set with env var instead of ScriptInfo.load so that it can be
466     # accessed early during a factory function.
467     os.environ["FLASK_DEBUG"] = "1" if value else "0"
468     return value
469 
470 
471 _debug_option = click.Option(
472     ["--debug/--no-debug"],
473     help="Set debug mode.",
474     expose_value=False,
475     callback=_set_debug,
476 )
477 
478 
479 def _env_file_callback(
480     ctx: click.Context, param: click.Option, value: str | None
481 ) -> str | None:
482     if value is None:
483         return None
484 
485     import importlib
486 
487     try:
488         importlib.import_module("dotenv")
489     except ImportError:
490         raise click.BadParameter(
491             "python-dotenv must be installed to load an env file.",
492             ctx=ctx,
493             param=param,
494         ) from None
495 
496     # Don't check FLASK_SKIP_DOTENV, that only disables automatically
497     # loading .env and .flaskenv files.
498     load_dotenv(value)
499     return value
500 
501 
502 # This option is eager so env vars are loaded as early as possible to be
503 # used by other options.
504 _env_file_option = click.Option(
505     ["-e", "--env-file"],
506     type=click.Path(exists=True, dir_okay=False),
507     help="Load environment variables from this file. python-dotenv must be installed.",
508     is_eager=True,
509     expose_value=False,
510     callback=_env_file_callback,
511 )
512 
513 
514 class FlaskGroup(AppGroup):
515     """Special subclass of the :class:`AppGroup` group that supports
516     loading more commands from the configured Flask app.  Normally a
517     developer does not have to interface with this class but there are
518     some very advanced use cases for which it makes sense to create an
519     instance of this. see :ref:`custom-scripts`.
520 
521     :param add_default_commands: if this is True then the default run and
522         shell commands will be added.
523     :param add_version_option: adds the ``--version`` option.
524     :param create_app: an optional callback that is passed the script info and
525         returns the loaded app.
526     :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
527         files to set environment variables. Will also change the working
528         directory to the directory containing the first file found.
529     :param set_debug_flag: Set the app's debug flag.
530 
531     .. versionchanged:: 2.2
532         Added the ``-A/--app``, ``--debug/--no-debug``, ``-e/--env-file`` options.
533 
534     .. versionchanged:: 2.2
535         An app context is pushed when running ``app.cli`` commands, so
536         ``@with_appcontext`` is no longer required for those commands.
537 
538     .. versionchanged:: 1.0
539         If installed, python-dotenv will be used to load environment variables
540         from :file:`.env` and :file:`.flaskenv` files.
541     """
542 
543     def __init__(
544         self,
545         add_default_commands: bool = True,
546         create_app: t.Callable[..., Flask] | None = None,
547         add_version_option: bool = True,
548         load_dotenv: bool = True,
549         set_debug_flag: bool = True,
550         **extra: t.Any,
551     ) -> None:
552         params = list(extra.pop("params", None) or ())
553         # Processing is done with option callbacks instead of a group
554         # callback. This allows users to make a custom group callback
555         # without losing the behavior. --env-file must come first so
556         # that it is eagerly evaluated before --app.
557         params.extend((_env_file_option, _app_option, _debug_option))
558 
559         if add_version_option:
560             params.append(version_option)
561 
562         if "context_settings" not in extra:
563             extra["context_settings"] = {}
564 
565         extra["context_settings"].setdefault("auto_envvar_prefix", "FLASK")
566 
567         super().__init__(params=params, **extra)
568 
569         self.create_app = create_app
570         self.load_dotenv = load_dotenv
571         self.set_debug_flag = set_debug_flag
572 
573         if add_default_commands:
574             self.add_command(run_command)
575             self.add_command(shell_command)
576             self.add_command(routes_command)
577 
578         self._loaded_plugin_commands = False
579 
580     def _load_plugin_commands(self) -> None:
581         if self._loaded_plugin_commands:
582             return
583 
584         if sys.version_info >= (3, 10):
585             from importlib import metadata
586         else:
587             # Use a backport on Python < 3.10. We technically have
588             # importlib.metadata on 3.8+, but the API changed in 3.10,
589             # so use the backport for consistency.
590             import importlib_metadata as metadata
591 
592         for ep in metadata.entry_points(group="flask.commands"):
593             self.add_command(ep.load(), ep.name)
594 
595         self._loaded_plugin_commands = True
596 
597     def get_command(self, ctx: click.Context, name: str) -> click.Command | None:
598         self._load_plugin_commands()
599         # Look up built-in and plugin commands, which should be
600         # available even if the app fails to load.
601         rv = super().get_command(ctx, name)
602 
603         if rv is not None:
604             return rv
605 
606         info = ctx.ensure_object(ScriptInfo)
607 
608         # Look up commands provided by the app, showing an error and
609         # continuing if the app couldn't be loaded.
610         try:
611             app = info.load_app()
612         except NoAppException as e:
613             click.secho(f"Error: {e.format_message()}\n", err=True, fg="red")
614             return None
615 
616         # Push an app context for the loaded app unless it is already
617         # active somehow. This makes the context available to parameter
618         # and command callbacks without needing @with_appcontext.
619         if not current_app or current_app._get_current_object() is not app:  # type: ignore[attr-defined]
620             ctx.with_resource(app.app_context())
621 
622         return app.cli.get_command(ctx, name)
623 
624     def list_commands(self, ctx: click.Context) -> list[str]:
625         self._load_plugin_commands()
626         # Start with the built-in and plugin commands.
627         rv = set(super().list_commands(ctx))
628         info = ctx.ensure_object(ScriptInfo)
629 
630         # Add commands provided by the app, showing an error and
631         # continuing if the app couldn't be loaded.
632         try:
633             rv.update(info.load_app().cli.list_commands(ctx))
634         except NoAppException as e:
635             # When an app couldn't be loaded, show the error message
636             # without the traceback.
637             click.secho(f"Error: {e.format_message()}\n", err=True, fg="red")
638         except Exception:
639             # When any other errors occurred during loading, show the
640             # full traceback.
641             click.secho(f"{traceback.format_exc()}\n", err=True, fg="red")
642 
643         return sorted(rv)
644 
645     def make_context(
646         self,
647         info_name: str | None,
648         args: list[str],
649         parent: click.Context | None = None,
650         **extra: t.Any,
651     ) -> click.Context:
652         # Set a flag to tell app.run to become a no-op. If app.run was
653         # not in a __name__ == __main__ guard, it would start the server
654         # when importing, blocking whatever command is being called.
655         os.environ["FLASK_RUN_FROM_CLI"] = "true"
656 
657         # Attempt to load .env and .flask env files. The --env-file
658         # option can cause another file to be loaded.
659         if get_load_dotenv(self.load_dotenv):
660             load_dotenv()
661 
662         if "obj" not in extra and "obj" not in self.context_settings:
663             extra["obj"] = ScriptInfo(
664                 create_app=self.create_app, set_debug_flag=self.set_debug_flag
665             )
666 
667         return super().make_context(info_name, args, parent=parent, **extra)
668 
669     def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:
670         if not args and self.no_args_is_help:
671             # Attempt to load --env-file and --app early in case they
672             # were given as env vars. Otherwise no_args_is_help will not
673             # see commands from app.cli.
674             _env_file_option.handle_parse_result(ctx, {}, [])
675             _app_option.handle_parse_result(ctx, {}, [])
676 
677         return super().parse_args(ctx, args)
678 
679 
680 def _path_is_ancestor(path: str, other: str) -> bool:
681     """Take ``other`` and remove the length of ``path`` from it. Then join it
682     to ``path``. If it is the original value, ``path`` is an ancestor of
683     ``other``."""
684     return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other
685 
686 
687 def load_dotenv(path: str | os.PathLike[str] | None = None) -> bool:
688     """Load "dotenv" files in order of precedence to set environment variables.
689 
690     If an env var is already set it is not overwritten, so earlier files in the
691     list are preferred over later files.
692 
693     This is a no-op if `python-dotenv`_ is not installed.
694 
695     .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme
696 
697     :param path: Load the file at this location instead of searching.
698     :return: ``True`` if a file was loaded.
699 
700     .. versionchanged:: 2.0
701         The current directory is not changed to the location of the
702         loaded file.
703 
704     .. versionchanged:: 2.0
705         When loading the env files, set the default encoding to UTF-8.
706 
707     .. versionchanged:: 1.1.0
708         Returns ``False`` when python-dotenv is not installed, or when
709         the given path isn't a file.
710 
711     .. versionadded:: 1.0
712     """
713     try:
714         import dotenv
715     except ImportError:
716         if path or os.path.isfile(".env") or os.path.isfile(".flaskenv"):
717             click.secho(
718                 " * Tip: There are .env or .flaskenv files present."
719                 ' Do "pip install python-dotenv" to use them.',
720                 fg="yellow",
721                 err=True,
722             )
723 
724         return False
725 
726     # Always return after attempting to load a given path, don't load
727     # the default files.
728     if path is not None:
729         if os.path.isfile(path):
730             return dotenv.load_dotenv(path, encoding="utf-8")
731 
732         return False
733 
734     loaded = False
735 
736     for name in (".env", ".flaskenv"):
737         path = dotenv.find_dotenv(name, usecwd=True)
738 
739         if not path:
740             continue
741 
742         dotenv.load_dotenv(path, encoding="utf-8")
743         loaded = True
744 
745     return loaded  # True if at least one file was located and loaded.
746 
747 
748 def show_server_banner(debug: bool, app_import_path: str | None) -> None:
749     """Show extra startup messages the first time the server is run,
750     ignoring the reloader.
751     """
752     if is_running_from_reloader():
753         return
754 
755     if app_import_path is not None:
756         click.echo(f" * Serving Flask app '{app_import_path}'")
757 
758     if debug is not None:
759         click.echo(f" * Debug mode: {'on' if debug else 'off'}")
760 
761 
762 class CertParamType(click.ParamType):
763     """Click option type for the ``--cert`` option. Allows either an
764     existing file, the string ``'adhoc'``, or an import for a
765     :class:`~ssl.SSLContext` object.
766     """
767 
768     name = "path"
769 
770     def __init__(self) -> None:
771         self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)
772 
773     def convert(
774         self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
775     ) -> t.Any:
776         try:
777             import ssl
778         except ImportError:
779             raise click.BadParameter(
780                 'Using "--cert" requires Python to be compiled with SSL support.',
781                 ctx,
782                 param,
783             ) from None
784 
785         try:
786             return self.path_type(value, param, ctx)
787         except click.BadParameter:
788             value = click.STRING(value, param, ctx).lower()
789 
790             if value == "adhoc":
791                 try:
792                     import cryptography  # noqa: F401
793                 except ImportError:
794                     raise click.BadParameter(
795                         "Using ad-hoc certificates requires the cryptography library.",
796                         ctx,
797                         param,
798                     ) from None
799 
800                 return value
801 
802             obj = import_string(value, silent=True)
803 
804             if isinstance(obj, ssl.SSLContext):
805                 return obj
806 
807             raise
808 
809 
810 def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:
811     """The ``--key`` option must be specified when ``--cert`` is a file.
812     Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
813     """
814     cert = ctx.params.get("cert")
815     is_adhoc = cert == "adhoc"
816 
817     try:
818         import ssl
819     except ImportError:
820         is_context = False
821     else:
822         is_context = isinstance(cert, ssl.SSLContext)
823 
824     if value is not None:
825         if is_adhoc:
826             raise click.BadParameter(
827                 'When "--cert" is "adhoc", "--key" is not used.', ctx, param
828             )
829 
830         if is_context:
831             raise click.BadParameter(
832                 'When "--cert" is an SSLContext object, "--key" is not used.',
833                 ctx,
834                 param,
835             )
836 
837         if not cert:
838             raise click.BadParameter('"--cert" must also be specified.', ctx, param)
839 
840         ctx.params["cert"] = cert, value
841 
842     else:
843         if cert and not (is_adhoc or is_context):
844             raise click.BadParameter('Required when using "--cert".', ctx, param)
845 
846     return value
847 
848 
849 class SeparatedPathType(click.Path):
850     """Click option type that accepts a list of values separated by the
851     OS's path separator (``:``, ``;`` on Windows). Each value is
852     validated as a :class:`click.Path` type.
853     """
854 
855     def convert(
856         self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None
857     ) -> t.Any:
858         items = self.split_envvar_value(value)
859         # can't call no-arg super() inside list comprehension until Python 3.12
860         super_convert = super().convert
861         return [super_convert(item, param, ctx) for item in items]
862 
863 
864 @click.command("run", short_help="Run a development server.")
865 @click.option("--host", "-h", default="127.0.0.1", help="The interface to bind to.")
866 @click.option("--port", "-p", default=5000, help="The port to bind to.")
867 @click.option(
868     "--cert",
869     type=CertParamType(),
870     help="Specify a certificate file to use HTTPS.",
871     is_eager=True,
872 )
873 @click.option(
874     "--key",
875     type=click.Path(exists=True, dir_okay=False, resolve_path=True),
876     callback=_validate_key,
877     expose_value=False,
878     help="The key file to use when specifying a certificate.",
879 )
880 @click.option(
881     "--reload/--no-reload",
882     default=None,
883     help="Enable or disable the reloader. By default the reloader "
884     "is active if debug is enabled.",
885 )
886 @click.option(
887     "--debugger/--no-debugger",
888     default=None,
889     help="Enable or disable the debugger. By default the debugger "
890     "is active if debug is enabled.",
891 )
892 @click.option(
893     "--with-threads/--without-threads",
894     default=True,
895     help="Enable or disable multithreading.",
896 )
897 @click.option(
898     "--extra-files",
899     default=None,
900     type=SeparatedPathType(),
901     help=(
902         "Extra files that trigger a reload on change. Multiple paths"
903         f" are separated by {os.path.pathsep!r}."
904     ),
905 )
906 @click.option(
907     "--exclude-patterns",
908     default=None,
909     type=SeparatedPathType(),
910     help=(
911         "Files matching these fnmatch patterns will not trigger a reload"
912         " on change. Multiple patterns are separated by"
913         f" {os.path.pathsep!r}."
914     ),
915 )
916 @pass_script_info
917 def run_command(
918     info: ScriptInfo,
919     host: str,
920     port: int,
921     reload: bool,
922     debugger: bool,
923     with_threads: bool,
924     cert: ssl.SSLContext | tuple[str, str | None] | t.Literal["adhoc"] | None,
925     extra_files: list[str] | None,
926     exclude_patterns: list[str] | None,
927 ) -> None:
928     """Run a local development server.
929 
930     This server is for development purposes only. It does not provide
931     the stability, security, or performance of production WSGI servers.
932 
933     The reloader and debugger are enabled by default with the '--debug'
934     option.
935     """
936     try:
937         app: WSGIApplication = info.load_app()
938     except Exception as e:
939         if is_running_from_reloader():
940             # When reloading, print out the error immediately, but raise
941             # it later so the debugger or server can handle it.
942             traceback.print_exc()
943             err = e
944 
945             def app(
946                 environ: WSGIEnvironment, start_response: StartResponse
947             ) -> cabc.Iterable[bytes]:
948                 raise err from None
949 
950         else:
951             # When not reloading, raise the error immediately so the
952             # command fails.
953             raise e from None
954 
955     debug = get_debug_flag()
956 
957     if reload is None:
958         reload = debug
959 
960     if debugger is None:
961         debugger = debug
962 
963     show_server_banner(debug, info.app_import_path)
964 
965     run_simple(
966         host,
967         port,
968         app,
969         use_reloader=reload,
970         use_debugger=debugger,
971         threaded=with_threads,
972         ssl_context=cert,
973         extra_files=extra_files,
974         exclude_patterns=exclude_patterns,
975     )
976 
977 
978 run_command.params.insert(0, _debug_option)
979 
980 
981 @click.command("shell", short_help="Run a shell in the app context.")
982 @with_appcontext
983 def shell_command() -> None:
984     """Run an interactive Python shell in the context of a given
985     Flask application.  The application will populate the default
986     namespace of this shell according to its configuration.
987 
988     This is useful for executing small snippets of management code
989     without having to manually configure the application.
990     """
991     import code
992 
993     banner = (
994         f"Python {sys.version} on {sys.platform}\n"
995         f"App: {current_app.import_name}\n"
996         f"Instance: {current_app.instance_path}"
997     )
998     ctx: dict[str, t.Any] = {}
999 
1000     # Support the regular Python interpreter startup script if someone
1001     # is using it.
1002     startup = os.environ.get("PYTHONSTARTUP")
1003     if startup and os.path.isfile(startup):
1004         with open(startup) as f:
1005             eval(compile(f.read(), startup, "exec"), ctx)
1006 
1007     ctx.update(current_app.make_shell_context())
1008 
1009     # Site, customize, or startup script can set a hook to call when
1010     # entering interactive mode. The default one sets up readline with
1011     # tab and history completion.
1012     interactive_hook = getattr(sys, "__interactivehook__", None)
1013 
1014     if interactive_hook is not None:
1015         try:
1016             import readline
1017             from rlcompleter import Completer
1018         except ImportError:
1019             pass
1020         else:
1021             # rlcompleter uses __main__.__dict__ by default, which is
1022             # flask.__main__. Use the shell context instead.
1023             readline.set_completer(Completer(ctx).complete)
1024 
1025         interactive_hook()
1026 
1027     code.interact(banner=banner, local=ctx)
1028 
1029 
1030 @click.command("routes", short_help="Show the routes for the app.")
1031 @click.option(
1032     "--sort",
1033     "-s",
1034     type=click.Choice(("endpoint", "methods", "domain", "rule", "match")),
1035     default="endpoint",
1036     help=(
1037         "Method to sort routes by. 'match' is the order that Flask will match routes"
1038         " when dispatching a request."
1039     ),
1040 )
1041 @click.option("--all-methods", is_flag=True, help="Show HEAD and OPTIONS methods.")
1042 @with_appcontext
1043 def routes_command(sort: str, all_methods: bool) -> None:
1044     """Show all registered routes with endpoints and methods."""
1045     rules = list(current_app.url_map.iter_rules())
1046 
1047     if not rules:
1048         click.echo("No routes were registered.")
1049         return
1050 
1051     ignored_methods = set() if all_methods else {"HEAD", "OPTIONS"}
1052     host_matching = current_app.url_map.host_matching
1053     has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)
1054     rows = []
1055 
1056     for rule in rules:
1057         row = [
1058             rule.endpoint,
1059             ", ".join(sorted((rule.methods or set()) - ignored_methods)),
1060         ]
1061 
1062         if has_domain:
1063             row.append((rule.host if host_matching else rule.subdomain) or "")
1064 
1065         row.append(rule.rule)
1066         rows.append(row)
1067 
1068     headers = ["Endpoint", "Methods"]
1069     sorts = ["endpoint", "methods"]
1070 
1071     if has_domain:
1072         headers.append("Host" if host_matching else "Subdomain")
1073         sorts.append("domain")
1074 
1075     headers.append("Rule")
1076     sorts.append("rule")
1077 
1078     try:
1079         rows.sort(key=itemgetter(sorts.index(sort)))
1080     except ValueError:
1081         pass
1082 
1083     rows.insert(0, headers)
1084     widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]
1085     rows.insert(1, ["-" * w for w in widths])
1086     template = "  ".join(f"{{{i}:<{w}}}" for i, w in enumerate(widths))
1087 
1088     for row in rows:
1089         click.echo(template.format(*row))
1090 
1091 
1092 cli = FlaskGroup(
1093     name="flask",
1094     help="""\
1095 A general utility script for Flask applications.
1096 
1097 An application to load must be given with the '--app' option,
1098 'FLASK_APP' environment variable, or with a 'wsgi.py' or 'app.py' file
1099 in the current directory.
1100 """,
1101 )
1102 
1103 
1104 def main() -> None:
1105     cli.main()
1106 
1107 
1108 if __name__ == "__main__":
1109     main()
1110 
======================================

FILE NAME : config.py =====
1 from __future__ import annotations
2 
3 import errno
4 import json
5 import os
6 import types
7 import typing as t
8 
9 from werkzeug.utils import import_string
10 
11 if t.TYPE_CHECKING:
12     import typing_extensions as te
13 
14     from .sansio.app import App
15 
16 
17 T = t.TypeVar("T")
18 
19 
20 class ConfigAttribute(t.Generic[T]):
21     """Makes an attribute forward to the config"""
22 
23     def __init__(
24         self, name: str, get_converter: t.Callable[[t.Any], T] | None = None
25     ) -> None:
26         self.__name__ = name
27         self.get_converter = get_converter
28 
29     @t.overload
30     def __get__(self, obj: None, owner: None) -> te.Self: ...
31 
32     @t.overload
33     def __get__(self, obj: App, owner: type[App]) -> T: ...
34 
35     def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:
36         if obj is None:
37             return self
38 
39         rv = obj.config[self.__name__]
40 
41         if self.get_converter is not None:
42             rv = self.get_converter(rv)
43 
44         return rv  # type: ignore[no-any-return]
45 
46     def __set__(self, obj: App, value: t.Any) -> None:
47         obj.config[self.__name__] = value
48 
49 
50 class Config(dict):  # type: ignore[type-arg]
51     """Works exactly like a dict but provides ways to fill it from files
52     or special dictionaries.  There are two common patterns to populate the
53     config.
54 
55     Either you can fill the config from a config file::
56 
57         app.config.from_pyfile('yourconfig.cfg')
58 
59     Or alternatively you can define the configuration options in the
60     module that calls :meth:`from_object` or provide an import path to
61     a module that should be loaded.  It is also possible to tell it to
62     use the same module and with that provide the configuration values
63     just before the call::
64 
65         DEBUG = True
66         SECRET_KEY = 'development key'
67         app.config.from_object(__name__)
68 
69     In both cases (loading from any Python file or loading from modules),
70     only uppercase keys are added to the config.  This makes it possible to use
71     lowercase values in the config file for temporary values that are not added
72     to the config or to define the config keys in the same file that implements
73     the application.
74 
75     Probably the most interesting way to load configurations is from an
76     environment variable pointing to a file::
77 
78         app.config.from_envvar('YOURAPPLICATION_SETTINGS')
79 
80     In this case before launching the application you have to set this
81     environment variable to the file you want to use.  On Linux and OS X
82     use the export statement::
83 
84         export YOURAPPLICATION_SETTINGS='/path/to/config/file'
85 
86     On windows use `set` instead.
87 
88     :param root_path: path to which files are read relative from.  When the
89                       config object is created by the application, this is
90                       the application's :attr:`~flask.Flask.root_path`.
91     :param defaults: an optional dictionary of default values
92     """
93 
94     def __init__(
95         self,
96         root_path: str | os.PathLike[str],
97         defaults: dict[str, t.Any] | None = None,
98     ) -> None:
99         super().__init__(defaults or {})
100         self.root_path = root_path
101 
102     def from_envvar(self, variable_name: str, silent: bool = False) -> bool:
103         """Loads a configuration from an environment variable pointing to
104         a configuration file.  This is basically just a shortcut with nicer
105         error messages for this line of code::
106 
107             app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])
108 
109         :param variable_name: name of the environment variable
110         :param silent: set to ``True`` if you want silent failure for missing
111                        files.
112         :return: ``True`` if the file was loaded successfully.
113         """
114         rv = os.environ.get(variable_name)
115         if not rv:
116             if silent:
117                 return False
118             raise RuntimeError(
119                 f"The environment variable {variable_name!r} is not set"
120                 " and as such configuration could not be loaded. Set"
121                 " this variable and make it point to a configuration"
122                 " file"
123             )
124         return self.from_pyfile(rv, silent=silent)
125 
126     def from_prefixed_env(
127         self, prefix: str = "FLASK", *, loads: t.Callable[[str], t.Any] = json.loads
128     ) -> bool:
129         """Load any environment variables that start with ``FLASK_``,
130         dropping the prefix from the env key for the config key. Values
131         are passed through a loading function to attempt to convert them
132         to more specific types than strings.
133 
134         Keys are loaded in :func:`sorted` order.
135 
136         The default loading function attempts to parse values as any
137         valid JSON type, including dicts and lists.
138 
139         Specific items in nested dicts can be set by separating the
140         keys with double underscores (``__``). If an intermediate key
141         doesn't exist, it will be initialized to an empty dict.
142 
143         :param prefix: Load env vars that start with this prefix,
144             separated with an underscore (``_``).
145         :param loads: Pass each string value to this function and use
146             the returned value as the config value. If any error is
147             raised it is ignored and the value remains a string. The
148             default is :func:`json.loads`.
149 
150         .. versionadded:: 2.1
151         """
152         prefix = f"{prefix}_"
153         len_prefix = len(prefix)
154 
155         for key in sorted(os.environ):
156             if not key.startswith(prefix):
157                 continue
158 
159             value = os.environ[key]
160 
161             try:
162                 value = loads(value)
163             except Exception:
164                 # Keep the value as a string if loading failed.
165                 pass
166 
167             # Change to key.removeprefix(prefix) on Python >= 3.9.
168             key = key[len_prefix:]
169 
170             if "__" not in key:
171                 # A non-nested key, set directly.
172                 self[key] = value
173                 continue
174 
175             # Traverse nested dictionaries with keys separated by "__".
176             current = self
177             *parts, tail = key.split("__")
178 
179             for part in parts:
180                 # If an intermediate dict does not exist, create it.
181                 if part not in current:
182                     current[part] = {}
183 
184                 current = current[part]
185 
186             current[tail] = value
187 
188         return True
189 
190     def from_pyfile(
191         self, filename: str | os.PathLike[str], silent: bool = False
192     ) -> bool:
193         """Updates the values in the config from a Python file.  This function
194         behaves as if the file was imported as module with the
195         :meth:`from_object` function.
196 
197         :param filename: the filename of the config.  This can either be an
198                          absolute filename or a filename relative to the
199                          root path.
200         :param silent: set to ``True`` if you want silent failure for missing
201                        files.
202         :return: ``True`` if the file was loaded successfully.
203 
204         .. versionadded:: 0.7
205            `silent` parameter.
206         """
207         filename = os.path.join(self.root_path, filename)
208         d = types.ModuleType("config")
209         d.__file__ = filename
210         try:
211             with open(filename, mode="rb") as config_file:
212                 exec(compile(config_file.read(), filename, "exec"), d.__dict__)
213         except OSError as e:
214             if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):
215                 return False
216             e.strerror = f"Unable to load configuration file ({e.strerror})"
217             raise
218         self.from_object(d)
219         return True
220 
221     def from_object(self, obj: object | str) -> None:
222         """Updates the values from the given object.  An object can be of one
223         of the following two types:
224 
225         -   a string: in this case the object with that name will be imported
226         -   an actual object reference: that object is used directly
227 
228         Objects are usually either modules or classes. :meth:`from_object`
229         loads only the uppercase attributes of the module/class. A ``dict``
230         object will not work with :meth:`from_object` because the keys of a
231         ``dict`` are not attributes of the ``dict`` class.
232 
233         Example of module-based configuration::
234 
235             app.config.from_object('yourapplication.default_config')
236             from yourapplication import default_config
237             app.config.from_object(default_config)
238 
239         Nothing is done to the object before loading. If the object is a
240         class and has ``@property`` attributes, it needs to be
241         instantiated before being passed to this method.
242 
243         You should not use this function to load the actual configuration but
244         rather configuration defaults.  The actual config should be loaded
245         with :meth:`from_pyfile` and ideally from a location not within the
246         package because the package might be installed system wide.
247 
248         See :ref:`config-dev-prod` for an example of class-based configuration
249         using :meth:`from_object`.
250 
251         :param obj: an import name or object
252         """
253         if isinstance(obj, str):
254             obj = import_string(obj)
255         for key in dir(obj):
256             if key.isupper():
257                 self[key] = getattr(obj, key)
258 
259     def from_file(
260         self,
261         filename: str | os.PathLike[str],
262         load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],
263         silent: bool = False,
264         text: bool = True,
265     ) -> bool:
266         """Update the values in the config from a file that is loaded
267         using the ``load`` parameter. The loaded data is passed to the
268         :meth:`from_mapping` method.
269 
270         .. code-block:: python
271 
272             import json
273             app.config.from_file("config.json", load=json.load)
274 
275             import tomllib
276             app.config.from_file("config.toml", load=tomllib.load, text=False)
277 
278         :param filename: The path to the data file. This can be an
279             absolute path or relative to the config root path.
280         :param load: A callable that takes a file handle and returns a
281             mapping of loaded data from the file.
282         :type load: ``Callable[[Reader], Mapping]`` where ``Reader``
283             implements a ``read`` method.
284         :param silent: Ignore the file if it doesn't exist.
285         :param text: Open the file in text or binary mode.
286         :return: ``True`` if the file was loaded successfully.
287 
288         .. versionchanged:: 2.3
289             The ``text`` parameter was added.
290 
291         .. versionadded:: 2.0
292         """
293         filename = os.path.join(self.root_path, filename)
294 
295         try:
296             with open(filename, "r" if text else "rb") as f:
297                 obj = load(f)
298         except OSError as e:
299             if silent and e.errno in (errno.ENOENT, errno.EISDIR):
300                 return False
301 
302             e.strerror = f"Unable to load configuration file ({e.strerror})"
303             raise
304 
305         return self.from_mapping(obj)
306 
307     def from_mapping(
308         self, mapping: t.Mapping[str, t.Any] | None = None, **kwargs: t.Any
309     ) -> bool:
310         """Updates the config like :meth:`update` ignoring items with
311         non-upper keys.
312 
313         :return: Always returns ``True``.
314 
315         .. versionadded:: 0.11
316         """
317         mappings: dict[str, t.Any] = {}
318         if mapping is not None:
319             mappings.update(mapping)
320         mappings.update(kwargs)
321         for key, value in mappings.items():
322             if key.isupper():
323                 self[key] = value
324         return True
325 
326     def get_namespace(
327         self, namespace: str, lowercase: bool = True, trim_namespace: bool = True
328     ) -> dict[str, t.Any]:
329         """Returns a dictionary containing a subset of configuration options
330         that match the specified namespace/prefix. Example usage::
331 
332             app.config['IMAGE_STORE_TYPE'] = 'fs'
333             app.config['IMAGE_STORE_PATH'] = '/var/app/images'
334             app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'
335             image_store_config = app.config.get_namespace('IMAGE_STORE_')
336 
337         The resulting dictionary `image_store_config` would look like::
338 
339             {
340                 'type': 'fs',
341                 'path': '/var/app/images',
342                 'base_url': 'http://img.website.com'
343             }
344 
345         This is often useful when configuration options map directly to
346         keyword arguments in functions or class constructors.
347 
348         :param namespace: a configuration namespace
349         :param lowercase: a flag indicating if the keys of the resulting
350                           dictionary should be lowercase
351         :param trim_namespace: a flag indicating if the keys of the resulting
352                           dictionary should not include the namespace
353 
354         .. versionadded:: 0.11
355         """
356         rv = {}
357         for k, v in self.items():
358             if not k.startswith(namespace):
359                 continue
360             if trim_namespace:
361                 key = k[len(namespace) :]
362             else:
363                 key = k
364             if lowercase:
365                 key = key.lower()
366             rv[key] = v
367         return rv
368 
369     def __repr__(self) -> str:
370         return f"<{type(self).__name__} {dict.__repr__(self)}>"
371 
======================================

FILE NAME : ctx.py =====
1 from __future__ import annotations
2 
3 import contextvars
4 import sys
5 import typing as t
6 from functools import update_wrapper
7 from types import TracebackType
8 
9 from werkzeug.exceptions import HTTPException
10 
11 from . import typing as ft
12 from .globals import _cv_app
13 from .globals import _cv_request
14 from .signals import appcontext_popped
15 from .signals import appcontext_pushed
16 
17 if t.TYPE_CHECKING:  # pragma: no cover
18     from _typeshed.wsgi import WSGIEnvironment
19 
20     from .app import Flask
21     from .sessions import SessionMixin
22     from .wrappers import Request
23 
24 
25 # a singleton sentinel value for parameter defaults
26 _sentinel = object()
27 
28 
29 class _AppCtxGlobals:
30     """A plain object. Used as a namespace for storing data during an
31     application context.
32 
33     Creating an app context automatically creates this object, which is
34     made available as the :data:`g` proxy.
35 
36     .. describe:: 'key' in g
37 
38         Check whether an attribute is present.
39 
40         .. versionadded:: 0.10
41 
42     .. describe:: iter(g)
43 
44         Return an iterator over the attribute names.
45 
46         .. versionadded:: 0.10
47     """
48 
49     # Define attr methods to let mypy know this is a namespace object
50     # that has arbitrary attributes.
51 
52     def __getattr__(self, name: str) -> t.Any:
53         try:
54             return self.__dict__[name]
55         except KeyError:
56             raise AttributeError(name) from None
57 
58     def __setattr__(self, name: str, value: t.Any) -> None:
59         self.__dict__[name] = value
60 
61     def __delattr__(self, name: str) -> None:
62         try:
63             del self.__dict__[name]
64         except KeyError:
65             raise AttributeError(name) from None
66 
67     def get(self, name: str, default: t.Any | None = None) -> t.Any:
68         """Get an attribute by name, or a default value. Like
69         :meth:`dict.get`.
70 
71         :param name: Name of attribute to get.
72         :param default: Value to return if the attribute is not present.
73 
74         .. versionadded:: 0.10
75         """
76         return self.__dict__.get(name, default)
77 
78     def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:
79         """Get and remove an attribute by name. Like :meth:`dict.pop`.
80 
81         :param name: Name of attribute to pop.
82         :param default: Value to return if the attribute is not present,
83             instead of raising a ``KeyError``.
84 
85         .. versionadded:: 0.11
86         """
87         if default is _sentinel:
88             return self.__dict__.pop(name)
89         else:
90             return self.__dict__.pop(name, default)
91 
92     def setdefault(self, name: str, default: t.Any = None) -> t.Any:
93         """Get the value of an attribute if it is present, otherwise
94         set and return a default value. Like :meth:`dict.setdefault`.
95 
96         :param name: Name of attribute to get.
97         :param default: Value to set and return if the attribute is not
98             present.
99 
100         .. versionadded:: 0.11
101         """
102         return self.__dict__.setdefault(name, default)
103 
104     def __contains__(self, item: str) -> bool:
105         return item in self.__dict__
106 
107     def __iter__(self) -> t.Iterator[str]:
108         return iter(self.__dict__)
109 
110     def __repr__(self) -> str:
111         ctx = _cv_app.get(None)
112         if ctx is not None:
113             return f"<flask.g of '{ctx.app.name}'>"
114         return object.__repr__(self)
115 
116 
117 def after_this_request(
118     f: ft.AfterRequestCallable[t.Any],
119 ) -> ft.AfterRequestCallable[t.Any]:
120     """Executes a function after this request.  This is useful to modify
121     response objects.  The function is passed the response object and has
122     to return the same or a new one.
123 
124     Example::
125 
126         @app.route('/')
127         def index():
128             @after_this_request
129             def add_header(response):
130                 response.headers['X-Foo'] = 'Parachute'
131                 return response
132             return 'Hello World!'
133 
134     This is more useful if a function other than the view function wants to
135     modify a response.  For instance think of a decorator that wants to add
136     some headers without converting the return value into a response object.
137 
138     .. versionadded:: 0.9
139     """
140     ctx = _cv_request.get(None)
141 
142     if ctx is None:
143         raise RuntimeError(
144             "'after_this_request' can only be used when a request"
145             " context is active, such as in a view function."
146         )
147 
148     ctx._after_request_functions.append(f)
149     return f
150 
151 
152 F = t.TypeVar("F", bound=t.Callable[..., t.Any])
153 
154 
155 def copy_current_request_context(f: F) -> F:
156     """A helper function that decorates a function to retain the current
157     request context.  This is useful when working with greenlets.  The moment
158     the function is decorated a copy of the request context is created and
159     then pushed when the function is called.  The current session is also
160     included in the copied request context.
161 
162     Example::
163 
164         import gevent
165         from flask import copy_current_request_context
166 
167         @app.route('/')
168         def index():
169             @copy_current_request_context
170             def do_some_work():
171                 # do some work here, it can access flask.request or
172                 # flask.session like you would otherwise in the view function.
173                 ...
174             gevent.spawn(do_some_work)
175             return 'Regular response'
176 
177     .. versionadded:: 0.10
178     """
179     ctx = _cv_request.get(None)
180 
181     if ctx is None:
182         raise RuntimeError(
183             "'copy_current_request_context' can only be used when a"
184             " request context is active, such as in a view function."
185         )
186 
187     ctx = ctx.copy()
188 
189     def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:
190         with ctx:  # type: ignore[union-attr]
191             return ctx.app.ensure_sync(f)(*args, **kwargs)  # type: ignore[union-attr]
192 
193     return update_wrapper(wrapper, f)  # type: ignore[return-value]
194 
195 
196 def has_request_context() -> bool:
197     """If you have code that wants to test if a request context is there or
198     not this function can be used.  For instance, you may want to take advantage
199     of request information if the request object is available, but fail
200     silently if it is unavailable.
201 
202     ::
203 
204         class User(db.Model):
205 
206             def __init__(self, username, remote_addr=None):
207                 self.username = username
208                 if remote_addr is None and has_request_context():
209                     remote_addr = request.remote_addr
210                 self.remote_addr = remote_addr
211 
212     Alternatively you can also just test any of the context bound objects
213     (such as :class:`request` or :class:`g`) for truthness::
214 
215         class User(db.Model):
216 
217             def __init__(self, username, remote_addr=None):
218                 self.username = username
219                 if remote_addr is None and request:
220                     remote_addr = request.remote_addr
221                 self.remote_addr = remote_addr
222 
223     .. versionadded:: 0.7
224     """
225     return _cv_request.get(None) is not None
226 
227 
228 def has_app_context() -> bool:
229     """Works like :func:`has_request_context` but for the application
230     context.  You can also just do a boolean check on the
231     :data:`current_app` object instead.
232 
233     .. versionadded:: 0.9
234     """
235     return _cv_app.get(None) is not None
236 
237 
238 class AppContext:
239     """The app context contains application-specific information. An app
240     context is created and pushed at the beginning of each request if
241     one is not already active. An app context is also pushed when
242     running CLI commands.
243     """
244 
245     def __init__(self, app: Flask) -> None:
246         self.app = app
247         self.url_adapter = app.create_url_adapter(None)
248         self.g: _AppCtxGlobals = app.app_ctx_globals_class()
249         self._cv_tokens: list[contextvars.Token[AppContext]] = []
250 
251     def push(self) -> None:
252         """Binds the app context to the current context."""
253         self._cv_tokens.append(_cv_app.set(self))
254         appcontext_pushed.send(self.app, _async_wrapper=self.app.ensure_sync)
255 
256     def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
257         """Pops the app context."""
258         try:
259             if len(self._cv_tokens) == 1:
260                 if exc is _sentinel:
261                     exc = sys.exc_info()[1]
262                 self.app.do_teardown_appcontext(exc)
263         finally:
264             ctx = _cv_app.get()
265             _cv_app.reset(self._cv_tokens.pop())
266 
267         if ctx is not self:
268             raise AssertionError(
269                 f"Popped wrong app context. ({ctx!r} instead of {self!r})"
270             )
271 
272         appcontext_popped.send(self.app, _async_wrapper=self.app.ensure_sync)
273 
274     def __enter__(self) -> AppContext:
275         self.push()
276         return self
277 
278     def __exit__(
279         self,
280         exc_type: type | None,
281         exc_value: BaseException | None,
282         tb: TracebackType | None,
283     ) -> None:
284         self.pop(exc_value)
285 
286 
287 class RequestContext:
288     """The request context contains per-request information. The Flask
289     app creates and pushes it at the beginning of the request, then pops
290     it at the end of the request. It will create the URL adapter and
291     request object for the WSGI environment provided.
292 
293     Do not attempt to use this class directly, instead use
294     :meth:`~flask.Flask.test_request_context` and
295     :meth:`~flask.Flask.request_context` to create this object.
296 
297     When the request context is popped, it will evaluate all the
298     functions registered on the application for teardown execution
299     (:meth:`~flask.Flask.teardown_request`).
300 
301     The request context is automatically popped at the end of the
302     request. When using the interactive debugger, the context will be
303     restored so ``request`` is still accessible. Similarly, the test
304     client can preserve the context after the request ends. However,
305     teardown functions may already have closed some resources such as
306     database connections.
307     """
308 
309     def __init__(
310         self,
311         app: Flask,
312         environ: WSGIEnvironment,
313         request: Request | None = None,
314         session: SessionMixin | None = None,
315     ) -> None:
316         self.app = app
317         if request is None:
318             request = app.request_class(environ)
319             request.json_module = app.json
320         self.request: Request = request
321         self.url_adapter = None
322         try:
323             self.url_adapter = app.create_url_adapter(self.request)
324         except HTTPException as e:
325             self.request.routing_exception = e
326         self.flashes: list[tuple[str, str]] | None = None
327         self.session: SessionMixin | None = session
328         # Functions that should be executed after the request on the response
329         # object.  These will be called before the regular "after_request"
330         # functions.
331         self._after_request_functions: list[ft.AfterRequestCallable[t.Any]] = []
332 
333         self._cv_tokens: list[
334             tuple[contextvars.Token[RequestContext], AppContext | None]
335         ] = []
336 
337     def copy(self) -> RequestContext:
338         """Creates a copy of this request context with the same request object.
339         This can be used to move a request context to a different greenlet.
340         Because the actual request object is the same this cannot be used to
341         move a request context to a different thread unless access to the
342         request object is locked.
343 
344         .. versionadded:: 0.10
345 
346         .. versionchanged:: 1.1
347            The current session object is used instead of reloading the original
348            data. This prevents `flask.session` pointing to an out-of-date object.
349         """
350         return self.__class__(
351             self.app,
352             environ=self.request.environ,
353             request=self.request,
354             session=self.session,
355         )
356 
357     def match_request(self) -> None:
358         """Can be overridden by a subclass to hook into the matching
359         of the request.
360         """
361         try:
362             result = self.url_adapter.match(return_rule=True)  # type: ignore
363             self.request.url_rule, self.request.view_args = result  # type: ignore
364         except HTTPException as e:
365             self.request.routing_exception = e
366 
367     def push(self) -> None:
368         # Before we push the request context we have to ensure that there
369         # is an application context.
370         app_ctx = _cv_app.get(None)
371 
372         if app_ctx is None or app_ctx.app is not self.app:
373             app_ctx = self.app.app_context()
374             app_ctx.push()
375         else:
376             app_ctx = None
377 
378         self._cv_tokens.append((_cv_request.set(self), app_ctx))
379 
380         # Open the session at the moment that the request context is available.
381         # This allows a custom open_session method to use the request context.
382         # Only open a new session if this is the first time the request was
383         # pushed, otherwise stream_with_context loses the session.
384         if self.session is None:
385             session_interface = self.app.session_interface
386             self.session = session_interface.open_session(self.app, self.request)
387 
388             if self.session is None:
389                 self.session = session_interface.make_null_session(self.app)
390 
391         # Match the request URL after loading the session, so that the
392         # session is available in custom URL converters.
393         if self.url_adapter is not None:
394             self.match_request()
395 
396     def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
397         """Pops the request context and unbinds it by doing that.  This will
398         also trigger the execution of functions registered by the
399         :meth:`~flask.Flask.teardown_request` decorator.
400 
401         .. versionchanged:: 0.9
402            Added the `exc` argument.
403         """
404         clear_request = len(self._cv_tokens) == 1
405 
406         try:
407             if clear_request:
408                 if exc is _sentinel:
409                     exc = sys.exc_info()[1]
410                 self.app.do_teardown_request(exc)
411 
412                 request_close = getattr(self.request, "close", None)
413                 if request_close is not None:
414                     request_close()
415         finally:
416             ctx = _cv_request.get()
417             token, app_ctx = self._cv_tokens.pop()
418             _cv_request.reset(token)
419 
420             # get rid of circular dependencies at the end of the request
421             # so that we don't require the GC to be active.
422             if clear_request:
423                 ctx.request.environ["werkzeug.request"] = None
424 
425             if app_ctx is not None:
426                 app_ctx.pop(exc)
427 
428             if ctx is not self:
429                 raise AssertionError(
430                     f"Popped wrong request context. ({ctx!r} instead of {self!r})"
431                 )
432 
433     def __enter__(self) -> RequestContext:
434         self.push()
435         return self
436 
437     def __exit__(
438         self,
439         exc_type: type | None,
440         exc_value: BaseException | None,
441         tb: TracebackType | None,
442     ) -> None:
443         self.pop(exc_value)
444 
445     def __repr__(self) -> str:
446         return (
447             f"<{type(self).__name__} {self.request.url!r}"
448             f" [{self.request.method}] of {self.app.name}>"
449         )
450 
======================================

FILE NAME : debughelpers.py =====
1 from __future__ import annotations
2 
3 import typing as t
4 
5 from jinja2.loaders import BaseLoader
6 from werkzeug.routing import RequestRedirect
7 
8 from .blueprints import Blueprint
9 from .globals import request_ctx
10 from .sansio.app import App
11 
12 if t.TYPE_CHECKING:
13     from .sansio.scaffold import Scaffold
14     from .wrappers import Request
15 
16 
17 class UnexpectedUnicodeError(AssertionError, UnicodeError):
18     """Raised in places where we want some better error reporting for
19     unexpected unicode or binary data.
20     """
21 
22 
23 class DebugFilesKeyError(KeyError, AssertionError):
24     """Raised from request.files during debugging.  The idea is that it can
25     provide a better error message than just a generic KeyError/BadRequest.
26     """
27 
28     def __init__(self, request: Request, key: str) -> None:
29         form_matches = request.form.getlist(key)
30         buf = [
31             f"You tried to access the file {key!r} in the request.files"
32             " dictionary but it does not exist. The mimetype for the"
33             f" request is {request.mimetype!r} instead of"
34             " 'multipart/form-data' which means that no file contents"
35             " were transmitted. To fix this error you should provide"
36             ' enctype="multipart/form-data" in your form.'
37         ]
38         if form_matches:
39             names = ", ".join(repr(x) for x in form_matches)
40             buf.append(
41                 "\n\nThe browser instead transmitted some file names. "
42                 f"This was submitted: {names}"
43             )
44         self.msg = "".join(buf)
45 
46     def __str__(self) -> str:
47         return self.msg
48 
49 
50 class FormDataRoutingRedirect(AssertionError):
51     """This exception is raised in debug mode if a routing redirect
52     would cause the browser to drop the method or body. This happens
53     when method is not GET, HEAD or OPTIONS and the status code is not
54     307 or 308.
55     """
56 
57     def __init__(self, request: Request) -> None:
58         exc = request.routing_exception
59         assert isinstance(exc, RequestRedirect)
60         buf = [
61             f"A request was sent to '{request.url}', but routing issued"
62             f" a redirect to the canonical URL '{exc.new_url}'."
63         ]
64 
65         if f"{request.base_url}/" == exc.new_url.partition("?")[0]:
66             buf.append(
67                 " The URL was defined with a trailing slash. Flask"
68                 " will redirect to the URL with a trailing slash if it"
69                 " was accessed without one."
70             )
71 
72         buf.append(
73             " Send requests to the canonical URL, or use 307 or 308 for"
74             " routing redirects. Otherwise, browsers will drop form"
75             " data.\n\n"
76             "This exception is only raised in debug mode."
77         )
78         super().__init__("".join(buf))
79 
80 
81 def attach_enctype_error_multidict(request: Request) -> None:
82     """Patch ``request.files.__getitem__`` to raise a descriptive error
83     about ``enctype=multipart/form-data``.
84 
85     :param request: The request to patch.
86     :meta private:
87     """
88     oldcls = request.files.__class__
89 
90     class newcls(oldcls):  # type: ignore[valid-type, misc]
91         def __getitem__(self, key: str) -> t.Any:
92             try:
93                 return super().__getitem__(key)
94             except KeyError as e:
95                 if key not in request.form:
96                     raise
97 
98                 raise DebugFilesKeyError(request, key).with_traceback(
99                     e.__traceback__
100                 ) from None
101 
102     newcls.__name__ = oldcls.__name__
103     newcls.__module__ = oldcls.__module__
104     request.files.__class__ = newcls
105 
106 
107 def _dump_loader_info(loader: BaseLoader) -> t.Iterator[str]:
108     yield f"class: {type(loader).__module__}.{type(loader).__name__}"
109     for key, value in sorted(loader.__dict__.items()):
110         if key.startswith("_"):
111             continue
112         if isinstance(value, (tuple, list)):
113             if not all(isinstance(x, str) for x in value):
114                 continue
115             yield f"{key}:"
116             for item in value:
117                 yield f"  - {item}"
118             continue
119         elif not isinstance(value, (str, int, float, bool)):
120             continue
121         yield f"{key}: {value!r}"
122 
123 
124 def explain_template_loading_attempts(
125     app: App,
126     template: str,
127     attempts: list[
128         tuple[
129             BaseLoader,
130             Scaffold,
131             tuple[str, str | None, t.Callable[[], bool] | None] | None,
132         ]
133     ],
134 ) -> None:
135     """This should help developers understand what failed"""
136     info = [f"Locating template {template!r}:"]
137     total_found = 0
138     blueprint = None
139     if request_ctx and request_ctx.request.blueprint is not None:
140         blueprint = request_ctx.request.blueprint
141 
142     for idx, (loader, srcobj, triple) in enumerate(attempts):
143         if isinstance(srcobj, App):
144             src_info = f"application {srcobj.import_name!r}"
145         elif isinstance(srcobj, Blueprint):
146             src_info = f"blueprint {srcobj.name!r} ({srcobj.import_name})"
147         else:
148             src_info = repr(srcobj)
149 
150         info.append(f"{idx + 1:5}: trying loader of {src_info}")
151 
152         for line in _dump_loader_info(loader):
153             info.append(f"       {line}")
154 
155         if triple is None:
156             detail = "no match"
157         else:
158             detail = f"found ({triple[1] or '<string>'!r})"
159             total_found += 1
160         info.append(f"       -> {detail}")
161 
162     seems_fishy = False
163     if total_found == 0:
164         info.append("Error: the template could not be found.")
165         seems_fishy = True
166     elif total_found > 1:
167         info.append("Warning: multiple loaders returned a match for the template.")
168         seems_fishy = True
169 
170     if blueprint is not None and seems_fishy:
171         info.append(
172             "  The template was looked up from an endpoint that belongs"
173             f" to the blueprint {blueprint!r}."
174         )
175         info.append("  Maybe you did not place a template in the right folder?")
176         info.append("  See https://flask.palletsprojects.com/blueprints/#templates")
177 
178     app.logger.info("\n".join(info))
179 
======================================

FILE NAME : globals.py =====
1 from __future__ import annotations
2 
3 import typing as t
4 from contextvars import ContextVar
5 
6 from werkzeug.local import LocalProxy
7 
8 if t.TYPE_CHECKING:  # pragma: no cover
9     from .app import Flask
10     from .ctx import _AppCtxGlobals
11     from .ctx import AppContext
12     from .ctx import RequestContext
13     from .sessions import SessionMixin
14     from .wrappers import Request
15 
16 
17 _no_app_msg = """\
18 Working outside of application context.
19 
20 This typically means that you attempted to use functionality that needed
21 the current application. To solve this, set up an application context
22 with app.app_context(). See the documentation for more information.\
23 """
24 _cv_app: ContextVar[AppContext] = ContextVar("flask.app_ctx")
25 app_ctx: AppContext = LocalProxy(  # type: ignore[assignment]
26     _cv_app, unbound_message=_no_app_msg
27 )
28 current_app: Flask = LocalProxy(  # type: ignore[assignment]
29     _cv_app, "app", unbound_message=_no_app_msg
30 )
31 g: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]
32     _cv_app, "g", unbound_message=_no_app_msg
33 )
34 
35 _no_req_msg = """\
36 Working outside of request context.
37 
38 This typically means that you attempted to use functionality that needed
39 an active HTTP request. Consult the documentation on testing for
40 information about how to avoid this problem.\
41 """
42 _cv_request: ContextVar[RequestContext] = ContextVar("flask.request_ctx")
43 request_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]
44     _cv_request, unbound_message=_no_req_msg
45 )
46 request: Request = LocalProxy(  # type: ignore[assignment]
47     _cv_request, "request", unbound_message=_no_req_msg
48 )
49 session: SessionMixin = LocalProxy(  # type: ignore[assignment]
50     _cv_request, "session", unbound_message=_no_req_msg
51 )
52 
======================================

FILE NAME : helpers.py =====
1 from __future__ import annotations
2 
3 import importlib.util
4 import os
5 import sys
6 import typing as t
7 from datetime import datetime
8 from functools import lru_cache
9 from functools import update_wrapper
10 
11 import werkzeug.utils
12 from werkzeug.exceptions import abort as _wz_abort
13 from werkzeug.utils import redirect as _wz_redirect
14 from werkzeug.wrappers import Response as BaseResponse
15 
16 from .globals import _cv_request
17 from .globals import current_app
18 from .globals import request
19 from .globals import request_ctx
20 from .globals import session
21 from .signals import message_flashed
22 
23 if t.TYPE_CHECKING:  # pragma: no cover
24     from .wrappers import Response
25 
26 
27 def get_debug_flag() -> bool:
28     """Get whether debug mode should be enabled for the app, indicated by the
29     :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.
30     """
31     val = os.environ.get("FLASK_DEBUG")
32     return bool(val and val.lower() not in {"0", "false", "no"})
33 
34 
35 def get_load_dotenv(default: bool = True) -> bool:
36     """Get whether the user has disabled loading default dotenv files by
37     setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load
38     the files.
39 
40     :param default: What to return if the env var isn't set.
41     """
42     val = os.environ.get("FLASK_SKIP_DOTENV")
43 
44     if not val:
45         return default
46 
47     return val.lower() in ("0", "false", "no")
48 
49 
50 def stream_with_context(
51     generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],
52 ) -> t.Iterator[t.AnyStr]:
53     """Request contexts disappear when the response is started on the server.
54     This is done for efficiency reasons and to make it less likely to encounter
55     memory leaks with badly written WSGI middlewares.  The downside is that if
56     you are using streamed responses, the generator cannot access request bound
57     information any more.
58 
59     This function however can help you keep the context around for longer::
60 
61         from flask import stream_with_context, request, Response
62 
63         @app.route('/stream')
64         def streamed_response():
65             @stream_with_context
66             def generate():
67                 yield 'Hello '
68                 yield request.args['name']
69                 yield '!'
70             return Response(generate())
71 
72     Alternatively it can also be used around a specific generator::
73 
74         from flask import stream_with_context, request, Response
75 
76         @app.route('/stream')
77         def streamed_response():
78             def generate():
79                 yield 'Hello '
80                 yield request.args['name']
81                 yield '!'
82             return Response(stream_with_context(generate()))
83 
84     .. versionadded:: 0.9
85     """
86     try:
87         gen = iter(generator_or_function)  # type: ignore[arg-type]
88     except TypeError:
89 
90         def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:
91             gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]
92             return stream_with_context(gen)
93 
94         return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type, return-value]
95 
96     def generator() -> t.Iterator[t.AnyStr | None]:
97         ctx = _cv_request.get(None)
98         if ctx is None:
99             raise RuntimeError(
100                 "'stream_with_context' can only be used when a request"
101                 " context is active, such as in a view function."
102             )
103         with ctx:
104             # Dummy sentinel.  Has to be inside the context block or we're
105             # not actually keeping the context around.
106             yield None
107 
108             # The try/finally is here so that if someone passes a WSGI level
109             # iterator in we're still running the cleanup logic.  Generators
110             # don't need that because they are closed on their destruction
111             # automatically.
112             try:
113                 yield from gen
114             finally:
115                 if hasattr(gen, "close"):
116                     gen.close()
117 
118     # The trick is to start the generator.  Then the code execution runs until
119     # the first dummy None is yielded at which point the context was already
120     # pushed.  This item is discarded.  Then when the iteration continues the
121     # real generator is executed.
122     wrapped_g = generator()
123     next(wrapped_g)
124     return wrapped_g  # type: ignore[return-value]
125 
126 
127 def make_response(*args: t.Any) -> Response:
128     """Sometimes it is necessary to set additional headers in a view.  Because
129     views do not have to return response objects but can return a value that
130     is converted into a response object by Flask itself, it becomes tricky to
131     add headers to it.  This function can be called instead of using a return
132     and you will get a response object which you can use to attach headers.
133 
134     If view looked like this and you want to add a new header::
135 
136         def index():
137             return render_template('index.html', foo=42)
138 
139     You can now do something like this::
140 
141         def index():
142             response = make_response(render_template('index.html', foo=42))
143             response.headers['X-Parachutes'] = 'parachutes are cool'
144             return response
145 
146     This function accepts the very same arguments you can return from a
147     view function.  This for example creates a response with a 404 error
148     code::
149 
150         response = make_response(render_template('not_found.html'), 404)
151 
152     The other use case of this function is to force the return value of a
153     view function into a response which is helpful with view
154     decorators::
155 
156         response = make_response(view_function())
157         response.headers['X-Parachutes'] = 'parachutes are cool'
158 
159     Internally this function does the following things:
160 
161     -   if no arguments are passed, it creates a new response argument
162     -   if one argument is passed, :meth:`flask.Flask.make_response`
163         is invoked with it.
164     -   if more than one argument is passed, the arguments are passed
165         to the :meth:`flask.Flask.make_response` function as tuple.
166 
167     .. versionadded:: 0.6
168     """
169     if not args:
170         return current_app.response_class()
171     if len(args) == 1:
172         args = args[0]
173     return current_app.make_response(args)
174 
175 
176 def url_for(
177     endpoint: str,
178     *,
179     _anchor: str | None = None,
180     _method: str | None = None,
181     _scheme: str | None = None,
182     _external: bool | None = None,
183     **values: t.Any,
184 ) -> str:
185     """Generate a URL to the given endpoint with the given values.
186 
187     This requires an active request or application context, and calls
188     :meth:`current_app.url_for() <flask.Flask.url_for>`. See that method
189     for full documentation.
190 
191     :param endpoint: The endpoint name associated with the URL to
192         generate. If this starts with a ``.``, the current blueprint
193         name (if any) will be used.
194     :param _anchor: If given, append this as ``#anchor`` to the URL.
195     :param _method: If given, generate the URL associated with this
196         method for the endpoint.
197     :param _scheme: If given, the URL will have this scheme if it is
198         external.
199     :param _external: If given, prefer the URL to be internal (False) or
200         require it to be external (True). External URLs include the
201         scheme and domain. When not in an active request, URLs are
202         external by default.
203     :param values: Values to use for the variable parts of the URL rule.
204         Unknown keys are appended as query string arguments, like
205         ``?a=b&c=d``.
206 
207     .. versionchanged:: 2.2
208         Calls ``current_app.url_for``, allowing an app to override the
209         behavior.
210 
211     .. versionchanged:: 0.10
212        The ``_scheme`` parameter was added.
213 
214     .. versionchanged:: 0.9
215        The ``_anchor`` and ``_method`` parameters were added.
216 
217     .. versionchanged:: 0.9
218        Calls ``app.handle_url_build_error`` on build errors.
219     """
220     return current_app.url_for(
221         endpoint,
222         _anchor=_anchor,
223         _method=_method,
224         _scheme=_scheme,
225         _external=_external,
226         **values,
227     )
228 
229 
230 def redirect(
231     location: str, code: int = 302, Response: type[BaseResponse] | None = None
232 ) -> BaseResponse:
233     """Create a redirect response object.
234 
235     If :data:`~flask.current_app` is available, it will use its
236     :meth:`~flask.Flask.redirect` method, otherwise it will use
237     :func:`werkzeug.utils.redirect`.
238 
239     :param location: The URL to redirect to.
240     :param code: The status code for the redirect.
241     :param Response: The response class to use. Not used when
242         ``current_app`` is active, which uses ``app.response_class``.
243 
244     .. versionadded:: 2.2
245         Calls ``current_app.redirect`` if available instead of always
246         using Werkzeug's default ``redirect``.
247     """
248     if current_app:
249         return current_app.redirect(location, code=code)
250 
251     return _wz_redirect(location, code=code, Response=Response)
252 
253 
254 def abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:
255     """Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given
256     status code.
257 
258     If :data:`~flask.current_app` is available, it will call its
259     :attr:`~flask.Flask.aborter` object, otherwise it will use
260     :func:`werkzeug.exceptions.abort`.
261 
262     :param code: The status code for the exception, which must be
263         registered in ``app.aborter``.
264     :param args: Passed to the exception.
265     :param kwargs: Passed to the exception.
266 
267     .. versionadded:: 2.2
268         Calls ``current_app.aborter`` if available instead of always
269         using Werkzeug's default ``abort``.
270     """
271     if current_app:
272         current_app.aborter(code, *args, **kwargs)
273 
274     _wz_abort(code, *args, **kwargs)
275 
276 
277 def get_template_attribute(template_name: str, attribute: str) -> t.Any:
278     """Loads a macro (or variable) a template exports.  This can be used to
279     invoke a macro from within Python code.  If you for example have a
280     template named :file:`_cider.html` with the following contents:
281 
282     .. sourcecode:: html+jinja
283 
284        {% macro hello(name) %}Hello {{ name }}!{% endmacro %}
285 
286     You can access this from Python code like this::
287 
288         hello = get_template_attribute('_cider.html', 'hello')
289         return hello('World')
290 
291     .. versionadded:: 0.2
292 
293     :param template_name: the name of the template
294     :param attribute: the name of the variable of macro to access
295     """
296     return getattr(current_app.jinja_env.get_template(template_name).module, attribute)
297 
298 
299 def flash(message: str, category: str = "message") -> None:
300     """Flashes a message to the next request.  In order to remove the
301     flashed message from the session and to display it to the user,
302     the template has to call :func:`get_flashed_messages`.
303 
304     .. versionchanged:: 0.3
305        `category` parameter added.
306 
307     :param message: the message to be flashed.
308     :param category: the category for the message.  The following values
309                      are recommended: ``'message'`` for any kind of message,
310                      ``'error'`` for errors, ``'info'`` for information
311                      messages and ``'warning'`` for warnings.  However any
312                      kind of string can be used as category.
313     """
314     # Original implementation:
315     #
316     #     session.setdefault('_flashes', []).append((category, message))
317     #
318     # This assumed that changes made to mutable structures in the session are
319     # always in sync with the session object, which is not true for session
320     # implementations that use external storage for keeping their keys/values.
321     flashes = session.get("_flashes", [])
322     flashes.append((category, message))
323     session["_flashes"] = flashes
324     app = current_app._get_current_object()  # type: ignore
325     message_flashed.send(
326         app,
327         _async_wrapper=app.ensure_sync,
328         message=message,
329         category=category,
330     )
331 
332 
333 def get_flashed_messages(
334     with_categories: bool = False, category_filter: t.Iterable[str] = ()
335 ) -> list[str] | list[tuple[str, str]]:
336     """Pulls all flashed messages from the session and returns them.
337     Further calls in the same request to the function will return
338     the same messages.  By default just the messages are returned,
339     but when `with_categories` is set to ``True``, the return value will
340     be a list of tuples in the form ``(category, message)`` instead.
341 
342     Filter the flashed messages to one or more categories by providing those
343     categories in `category_filter`.  This allows rendering categories in
344     separate html blocks.  The `with_categories` and `category_filter`
345     arguments are distinct:
346 
347     * `with_categories` controls whether categories are returned with message
348       text (``True`` gives a tuple, where ``False`` gives just the message text).
349     * `category_filter` filters the messages down to only those matching the
350       provided categories.
351 
352     See :doc:`/patterns/flashing` for examples.
353 
354     .. versionchanged:: 0.3
355        `with_categories` parameter added.
356 
357     .. versionchanged:: 0.9
358         `category_filter` parameter added.
359 
360     :param with_categories: set to ``True`` to also receive categories.
361     :param category_filter: filter of categories to limit return values.  Only
362                             categories in the list will be returned.
363     """
364     flashes = request_ctx.flashes
365     if flashes is None:
366         flashes = session.pop("_flashes") if "_flashes" in session else []
367         request_ctx.flashes = flashes
368     if category_filter:
369         flashes = list(filter(lambda f: f[0] in category_filter, flashes))
370     if not with_categories:
371         return [x[1] for x in flashes]
372     return flashes
373 
374 
375 def _prepare_send_file_kwargs(**kwargs: t.Any) -> dict[str, t.Any]:
376     if kwargs.get("max_age") is None:
377         kwargs["max_age"] = current_app.get_send_file_max_age
378 
379     kwargs.update(
380         environ=request.environ,
381         use_x_sendfile=current_app.config["USE_X_SENDFILE"],
382         response_class=current_app.response_class,
383         _root_path=current_app.root_path,  # type: ignore
384     )
385     return kwargs
386 
387 
388 def send_file(
389     path_or_file: os.PathLike[t.AnyStr] | str | t.BinaryIO,
390     mimetype: str | None = None,
391     as_attachment: bool = False,
392     download_name: str | None = None,
393     conditional: bool = True,
394     etag: bool | str = True,
395     last_modified: datetime | int | float | None = None,
396     max_age: None | (int | t.Callable[[str | None], int | None]) = None,
397 ) -> Response:
398     """Send the contents of a file to the client.
399 
400     The first argument can be a file path or a file-like object. Paths
401     are preferred in most cases because Werkzeug can manage the file and
402     get extra information from the path. Passing a file-like object
403     requires that the file is opened in binary mode, and is mostly
404     useful when building a file in memory with :class:`io.BytesIO`.
405 
406     Never pass file paths provided by a user. The path is assumed to be
407     trusted, so a user could craft a path to access a file you didn't
408     intend. Use :func:`send_from_directory` to safely serve
409     user-requested paths from within a directory.
410 
411     If the WSGI server sets a ``file_wrapper`` in ``environ``, it is
412     used, otherwise Werkzeug's built-in wrapper is used. Alternatively,
413     if the HTTP server supports ``X-Sendfile``, configuring Flask with
414     ``USE_X_SENDFILE = True`` will tell the server to send the given
415     path, which is much more efficient than reading it in Python.
416 
417     :param path_or_file: The path to the file to send, relative to the
418         current working directory if a relative path is given.
419         Alternatively, a file-like object opened in binary mode. Make
420         sure the file pointer is seeked to the start of the data.
421     :param mimetype: The MIME type to send for the file. If not
422         provided, it will try to detect it from the file name.
423     :param as_attachment: Indicate to a browser that it should offer to
424         save the file instead of displaying it.
425     :param download_name: The default name browsers will use when saving
426         the file. Defaults to the passed file name.
427     :param conditional: Enable conditional and range responses based on
428         request headers. Requires passing a file path and ``environ``.
429     :param etag: Calculate an ETag for the file, which requires passing
430         a file path. Can also be a string to use instead.
431     :param last_modified: The last modified time to send for the file,
432         in seconds. If not provided, it will try to detect it from the
433         file path.
434     :param max_age: How long the client should cache the file, in
435         seconds. If set, ``Cache-Control`` will be ``public``, otherwise
436         it will be ``no-cache`` to prefer conditional caching.
437 
438     .. versionchanged:: 2.0
439         ``download_name`` replaces the ``attachment_filename``
440         parameter. If ``as_attachment=False``, it is passed with
441         ``Content-Disposition: inline`` instead.
442 
443     .. versionchanged:: 2.0
444         ``max_age`` replaces the ``cache_timeout`` parameter.
445         ``conditional`` is enabled and ``max_age`` is not set by
446         default.
447 
448     .. versionchanged:: 2.0
449         ``etag`` replaces the ``add_etags`` parameter. It can be a
450         string to use instead of generating one.
451 
452     .. versionchanged:: 2.0
453         Passing a file-like object that inherits from
454         :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather
455         than sending an empty file.
456 
457     .. versionadded:: 2.0
458         Moved the implementation to Werkzeug. This is now a wrapper to
459         pass some Flask-specific arguments.
460 
461     .. versionchanged:: 1.1
462         ``filename`` may be a :class:`~os.PathLike` object.
463 
464     .. versionchanged:: 1.1
465         Passing a :class:`~io.BytesIO` object supports range requests.
466 
467     .. versionchanged:: 1.0.3
468         Filenames are encoded with ASCII instead of Latin-1 for broader
469         compatibility with WSGI servers.
470 
471     .. versionchanged:: 1.0
472         UTF-8 filenames as specified in :rfc:`2231` are supported.
473 
474     .. versionchanged:: 0.12
475         The filename is no longer automatically inferred from file
476         objects. If you want to use automatic MIME and etag support,
477         pass a filename via ``filename_or_fp`` or
478         ``attachment_filename``.
479 
480     .. versionchanged:: 0.12
481         ``attachment_filename`` is preferred over ``filename`` for MIME
482         detection.
483 
484     .. versionchanged:: 0.9
485         ``cache_timeout`` defaults to
486         :meth:`Flask.get_send_file_max_age`.
487 
488     .. versionchanged:: 0.7
489         MIME guessing and etag support for file-like objects was
490         removed because it was unreliable. Pass a filename if you are
491         able to, otherwise attach an etag yourself.
492 
493     .. versionchanged:: 0.5
494         The ``add_etags``, ``cache_timeout`` and ``conditional``
495         parameters were added. The default behavior is to add etags.
496 
497     .. versionadded:: 0.2
498     """
499     return werkzeug.utils.send_file(  # type: ignore[return-value]
500         **_prepare_send_file_kwargs(
501             path_or_file=path_or_file,
502             environ=request.environ,
503             mimetype=mimetype,
504             as_attachment=as_attachment,
505             download_name=download_name,
506             conditional=conditional,
507             etag=etag,
508             last_modified=last_modified,
509             max_age=max_age,
510         )
511     )
512 
513 
514 def send_from_directory(
515     directory: os.PathLike[str] | str,
516     path: os.PathLike[str] | str,
517     **kwargs: t.Any,
518 ) -> Response:
519     """Send a file from within a directory using :func:`send_file`.
520 
521     .. code-block:: python
522 
523         @app.route("/uploads/<path:name>")
524         def download_file(name):
525             return send_from_directory(
526                 app.config['UPLOAD_FOLDER'], name, as_attachment=True
527             )
528 
529     This is a secure way to serve files from a folder, such as static
530     files or uploads. Uses :func:`~werkzeug.security.safe_join` to
531     ensure the path coming from the client is not maliciously crafted to
532     point outside the specified directory.
533 
534     If the final path does not point to an existing regular file,
535     raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.
536 
537     :param directory: The directory that ``path`` must be located under,
538         relative to the current application's root path.
539     :param path: The path to the file to send, relative to
540         ``directory``.
541     :param kwargs: Arguments to pass to :func:`send_file`.
542 
543     .. versionchanged:: 2.0
544         ``path`` replaces the ``filename`` parameter.
545 
546     .. versionadded:: 2.0
547         Moved the implementation to Werkzeug. This is now a wrapper to
548         pass some Flask-specific arguments.
549 
550     .. versionadded:: 0.5
551     """
552     return werkzeug.utils.send_from_directory(  # type: ignore[return-value]
553         directory, path, **_prepare_send_file_kwargs(**kwargs)
554     )
555 
556 
557 def get_root_path(import_name: str) -> str:
558     """Find the root path of a package, or the path that contains a
559     module. If it cannot be found, returns the current working
560     directory.
561 
562     Not to be confused with the value returned by :func:`find_package`.
563 
564     :meta private:
565     """
566     # Module already imported and has a file attribute. Use that first.
567     mod = sys.modules.get(import_name)
568 
569     if mod is not None and hasattr(mod, "__file__") and mod.__file__ is not None:
570         return os.path.dirname(os.path.abspath(mod.__file__))
571 
572     # Next attempt: check the loader.
573     try:
574         spec = importlib.util.find_spec(import_name)
575 
576         if spec is None:
577             raise ValueError
578     except (ImportError, ValueError):
579         loader = None
580     else:
581         loader = spec.loader
582 
583     # Loader does not exist or we're referring to an unloaded main
584     # module or a main module without path (interactive sessions), go
585     # with the current working directory.
586     if loader is None:
587         return os.getcwd()
588 
589     if hasattr(loader, "get_filename"):
590         filepath = loader.get_filename(import_name)
591     else:
592         # Fall back to imports.
593         __import__(import_name)
594         mod = sys.modules[import_name]
595         filepath = getattr(mod, "__file__", None)
596 
597         # If we don't have a file path it might be because it is a
598         # namespace package. In this case pick the root path from the
599         # first module that is contained in the package.
600         if filepath is None:
601             raise RuntimeError(
602                 "No root path can be found for the provided module"
603                 f" {import_name!r}. This can happen because the module"
604                 " came from an import hook that does not provide file"
605                 " name information or because it's a namespace package."
606                 " In this case the root path needs to be explicitly"
607                 " provided."
608             )
609 
610     # filepath is import_name.py for a module, or __init__.py for a package.
611     return os.path.dirname(os.path.abspath(filepath))  # type: ignore[no-any-return]
612 
613 
614 @lru_cache(maxsize=None)
615 def _split_blueprint_path(name: str) -> list[str]:
616     out: list[str] = [name]
617 
618     if "." in name:
619         out.extend(_split_blueprint_path(name.rpartition(".")[0]))
620 
621     return out
622 
======================================

FILE NAME : logging.py =====
1 from __future__ import annotations
2 
3 import logging
4 import sys
5 import typing as t
6 
7 from werkzeug.local import LocalProxy
8 
9 from .globals import request
10 
11 if t.TYPE_CHECKING:  # pragma: no cover
12     from .sansio.app import App
13 
14 
15 @LocalProxy
16 def wsgi_errors_stream() -> t.TextIO:
17     """Find the most appropriate error stream for the application. If a request
18     is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.
19 
20     If you configure your own :class:`logging.StreamHandler`, you may want to
21     use this for the stream. If you are using file or dict configuration and
22     can't import this directly, you can refer to it as
23     ``ext://flask.logging.wsgi_errors_stream``.
24     """
25     if request:
26         return request.environ["wsgi.errors"]  # type: ignore[no-any-return]
27 
28     return sys.stderr
29 
30 
31 def has_level_handler(logger: logging.Logger) -> bool:
32     """Check if there is a handler in the logging chain that will handle the
33     given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.
34     """
35     level = logger.getEffectiveLevel()
36     current = logger
37 
38     while current:
39         if any(handler.level <= level for handler in current.handlers):
40             return True
41 
42         if not current.propagate:
43             break
44 
45         current = current.parent  # type: ignore
46 
47     return False
48 
49 
50 #: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format
51 #: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.
52 default_handler = logging.StreamHandler(wsgi_errors_stream)  # type: ignore
53 default_handler.setFormatter(
54     logging.Formatter("[%(asctime)s] %(levelname)s in %(module)s: %(message)s")
55 )
56 
57 
58 def create_logger(app: App) -> logging.Logger:
59     """Get the Flask app's logger and configure it if needed.
60 
61     The logger name will be the same as
62     :attr:`app.import_name <flask.Flask.name>`.
63 
64     When :attr:`~flask.Flask.debug` is enabled, set the logger level to
65     :data:`logging.DEBUG` if it is not set.
66 
67     If there is no handler for the logger's effective level, add a
68     :class:`~logging.StreamHandler` for
69     :func:`~flask.logging.wsgi_errors_stream` with a basic format.
70     """
71     logger = logging.getLogger(app.name)
72 
73     if app.debug and not logger.level:
74         logger.setLevel(logging.DEBUG)
75 
76     if not has_level_handler(logger):
77         logger.addHandler(default_handler)
78 
79     return logger
80 
======================================

FILE NAME : sessions.py =====
1 from __future__ import annotations
2 
3 import hashlib
4 import typing as t
5 from collections.abc import MutableMapping
6 from datetime import datetime
7 from datetime import timezone
8 
9 from itsdangerous import BadSignature
10 from itsdangerous import URLSafeTimedSerializer
11 from werkzeug.datastructures import CallbackDict
12 
13 from .json.tag import TaggedJSONSerializer
14 
15 if t.TYPE_CHECKING:  # pragma: no cover
16     import typing_extensions as te
17 
18     from .app import Flask
19     from .wrappers import Request
20     from .wrappers import Response
21 
22 
23 # TODO generic when Python > 3.8
24 class SessionMixin(MutableMapping):  # type: ignore[type-arg]
25     """Expands a basic dictionary with session attributes."""
26 
27     @property
28     def permanent(self) -> bool:
29         """This reflects the ``'_permanent'`` key in the dict."""
30         return self.get("_permanent", False)
31 
32     @permanent.setter
33     def permanent(self, value: bool) -> None:
34         self["_permanent"] = bool(value)
35 
36     #: Some implementations can detect whether a session is newly
37     #: created, but that is not guaranteed. Use with caution. The mixin
38     # default is hard-coded ``False``.
39     new = False
40 
41     #: Some implementations can detect changes to the session and set
42     #: this when that happens. The mixin default is hard coded to
43     #: ``True``.
44     modified = True
45 
46     #: Some implementations can detect when session data is read or
47     #: written and set this when that happens. The mixin default is hard
48     #: coded to ``True``.
49     accessed = True
50 
51 
52 # TODO generic when Python > 3.8
53 class SecureCookieSession(CallbackDict, SessionMixin):  # type: ignore[type-arg]
54     """Base class for sessions based on signed cookies.
55 
56     This session backend will set the :attr:`modified` and
57     :attr:`accessed` attributes. It cannot reliably track whether a
58     session is new (vs. empty), so :attr:`new` remains hard coded to
59     ``False``.
60     """
61 
62     #: When data is changed, this is set to ``True``. Only the session
63     #: dictionary itself is tracked; if the session contains mutable
64     #: data (for example a nested dict) then this must be set to
65     #: ``True`` manually when modifying that data. The session cookie
66     #: will only be written to the response if this is ``True``.
67     modified = False
68 
69     #: When data is read or written, this is set to ``True``. Used by
70     # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``
71     #: header, which allows caching proxies to cache different pages for
72     #: different users.
73     accessed = False
74 
75     def __init__(self, initial: t.Any = None) -> None:
76         def on_update(self: te.Self) -> None:
77             self.modified = True
78             self.accessed = True
79 
80         super().__init__(initial, on_update)
81 
82     def __getitem__(self, key: str) -> t.Any:
83         self.accessed = True
84         return super().__getitem__(key)
85 
86     def get(self, key: str, default: t.Any = None) -> t.Any:
87         self.accessed = True
88         return super().get(key, default)
89 
90     def setdefault(self, key: str, default: t.Any = None) -> t.Any:
91         self.accessed = True
92         return super().setdefault(key, default)
93 
94 
95 class NullSession(SecureCookieSession):
96     """Class used to generate nicer error messages if sessions are not
97     available.  Will still allow read-only access to the empty session
98     but fail on setting.
99     """
100 
101     def _fail(self, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:
102         raise RuntimeError(
103             "The session is unavailable because no secret "
104             "key was set.  Set the secret_key on the "
105             "application to something unique and secret."
106         )
107 
108     __setitem__ = __delitem__ = clear = pop = popitem = update = setdefault = _fail  # type: ignore # noqa: B950
109     del _fail
110 
111 
112 class SessionInterface:
113     """The basic interface you have to implement in order to replace the
114     default session interface which uses werkzeug's securecookie
115     implementation.  The only methods you have to implement are
116     :meth:`open_session` and :meth:`save_session`, the others have
117     useful defaults which you don't need to change.
118 
119     The session object returned by the :meth:`open_session` method has to
120     provide a dictionary like interface plus the properties and methods
121     from the :class:`SessionMixin`.  We recommend just subclassing a dict
122     and adding that mixin::
123 
124         class Session(dict, SessionMixin):
125             pass
126 
127     If :meth:`open_session` returns ``None`` Flask will call into
128     :meth:`make_null_session` to create a session that acts as replacement
129     if the session support cannot work because some requirement is not
130     fulfilled.  The default :class:`NullSession` class that is created
131     will complain that the secret key was not set.
132 
133     To replace the session interface on an application all you have to do
134     is to assign :attr:`flask.Flask.session_interface`::
135 
136         app = Flask(__name__)
137         app.session_interface = MySessionInterface()
138 
139     Multiple requests with the same session may be sent and handled
140     concurrently. When implementing a new session interface, consider
141     whether reads or writes to the backing store must be synchronized.
142     There is no guarantee on the order in which the session for each
143     request is opened or saved, it will occur in the order that requests
144     begin and end processing.
145 
146     .. versionadded:: 0.8
147     """
148 
149     #: :meth:`make_null_session` will look here for the class that should
150     #: be created when a null session is requested.  Likewise the
151     #: :meth:`is_null_session` method will perform a typecheck against
152     #: this type.
153     null_session_class = NullSession
154 
155     #: A flag that indicates if the session interface is pickle based.
156     #: This can be used by Flask extensions to make a decision in regards
157     #: to how to deal with the session object.
158     #:
159     #: .. versionadded:: 0.10
160     pickle_based = False
161 
162     def make_null_session(self, app: Flask) -> NullSession:
163         """Creates a null session which acts as a replacement object if the
164         real session support could not be loaded due to a configuration
165         error.  This mainly aids the user experience because the job of the
166         null session is to still support lookup without complaining but
167         modifications are answered with a helpful error message of what
168         failed.
169 
170         This creates an instance of :attr:`null_session_class` by default.
171         """
172         return self.null_session_class()
173 
174     def is_null_session(self, obj: object) -> bool:
175         """Checks if a given object is a null session.  Null sessions are
176         not asked to be saved.
177 
178         This checks if the object is an instance of :attr:`null_session_class`
179         by default.
180         """
181         return isinstance(obj, self.null_session_class)
182 
183     def get_cookie_name(self, app: Flask) -> str:
184         """The name of the session cookie. Uses``app.config["SESSION_COOKIE_NAME"]``."""
185         return app.config["SESSION_COOKIE_NAME"]  # type: ignore[no-any-return]
186 
187     def get_cookie_domain(self, app: Flask) -> str | None:
188         """The value of the ``Domain`` parameter on the session cookie. If not set,
189         browsers will only send the cookie to the exact domain it was set from.
190         Otherwise, they will send it to any subdomain of the given value as well.
191 
192         Uses the :data:`SESSION_COOKIE_DOMAIN` config.
193 
194         .. versionchanged:: 2.3
195             Not set by default, does not fall back to ``SERVER_NAME``.
196         """
197         return app.config["SESSION_COOKIE_DOMAIN"]  # type: ignore[no-any-return]
198 
199     def get_cookie_path(self, app: Flask) -> str:
200         """Returns the path for which the cookie should be valid.  The
201         default implementation uses the value from the ``SESSION_COOKIE_PATH``
202         config var if it's set, and falls back to ``APPLICATION_ROOT`` or
203         uses ``/`` if it's ``None``.
204         """
205         return app.config["SESSION_COOKIE_PATH"] or app.config["APPLICATION_ROOT"]  # type: ignore[no-any-return]
206 
207     def get_cookie_httponly(self, app: Flask) -> bool:
208         """Returns True if the session cookie should be httponly.  This
209         currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``
210         config var.
211         """
212         return app.config["SESSION_COOKIE_HTTPONLY"]  # type: ignore[no-any-return]
213 
214     def get_cookie_secure(self, app: Flask) -> bool:
215         """Returns True if the cookie should be secure.  This currently
216         just returns the value of the ``SESSION_COOKIE_SECURE`` setting.
217         """
218         return app.config["SESSION_COOKIE_SECURE"]  # type: ignore[no-any-return]
219 
220     def get_cookie_samesite(self, app: Flask) -> str | None:
221         """Return ``'Strict'`` or ``'Lax'`` if the cookie should use the
222         ``SameSite`` attribute. This currently just returns the value of
223         the :data:`SESSION_COOKIE_SAMESITE` setting.
224         """
225         return app.config["SESSION_COOKIE_SAMESITE"]  # type: ignore[no-any-return]
226 
227     def get_expiration_time(self, app: Flask, session: SessionMixin) -> datetime | None:
228         """A helper method that returns an expiration date for the session
229         or ``None`` if the session is linked to the browser session.  The
230         default implementation returns now + the permanent session
231         lifetime configured on the application.
232         """
233         if session.permanent:
234             return datetime.now(timezone.utc) + app.permanent_session_lifetime
235         return None
236 
237     def should_set_cookie(self, app: Flask, session: SessionMixin) -> bool:
238         """Used by session backends to determine if a ``Set-Cookie`` header
239         should be set for this session cookie for this response. If the session
240         has been modified, the cookie is set. If the session is permanent and
241         the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is
242         always set.
243 
244         This check is usually skipped if the session was deleted.
245 
246         .. versionadded:: 0.11
247         """
248 
249         return session.modified or (
250             session.permanent and app.config["SESSION_REFRESH_EACH_REQUEST"]
251         )
252 
253     def open_session(self, app: Flask, request: Request) -> SessionMixin | None:
254         """This is called at the beginning of each request, after
255         pushing the request context, before matching the URL.
256 
257         This must return an object which implements a dictionary-like
258         interface as well as the :class:`SessionMixin` interface.
259 
260         This will return ``None`` to indicate that loading failed in
261         some way that is not immediately an error. The request
262         context will fall back to using :meth:`make_null_session`
263         in this case.
264         """
265         raise NotImplementedError()
266 
267     def save_session(
268         self, app: Flask, session: SessionMixin, response: Response
269     ) -> None:
270         """This is called at the end of each request, after generating
271         a response, before removing the request context. It is skipped
272         if :meth:`is_null_session` returns ``True``.
273         """
274         raise NotImplementedError()
275 
276 
277 session_json_serializer = TaggedJSONSerializer()
278 
279 
280 def _lazy_sha1(string: bytes = b"") -> t.Any:
281     """Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include
282     SHA-1, in which case the import and use as a default would fail before the
283     developer can configure something else.
284     """
285     return hashlib.sha1(string)
286 
287 
288 class SecureCookieSessionInterface(SessionInterface):
289     """The default session interface that stores sessions in signed cookies
290     through the :mod:`itsdangerous` module.
291     """
292 
293     #: the salt that should be applied on top of the secret key for the
294     #: signing of cookie based sessions.
295     salt = "cookie-session"
296     #: the hash function to use for the signature.  The default is sha1
297     digest_method = staticmethod(_lazy_sha1)
298     #: the name of the itsdangerous supported key derivation.  The default
299     #: is hmac.
300     key_derivation = "hmac"
301     #: A python serializer for the payload.  The default is a compact
302     #: JSON derived serializer with support for some extra Python types
303     #: such as datetime objects or tuples.
304     serializer = session_json_serializer
305     session_class = SecureCookieSession
306 
307     def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:
308         if not app.secret_key:
309             return None
310         signer_kwargs = dict(
311             key_derivation=self.key_derivation, digest_method=self.digest_method
312         )
313         return URLSafeTimedSerializer(
314             app.secret_key,
315             salt=self.salt,
316             serializer=self.serializer,
317             signer_kwargs=signer_kwargs,
318         )
319 
320     def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:
321         s = self.get_signing_serializer(app)
322         if s is None:
323             return None
324         val = request.cookies.get(self.get_cookie_name(app))
325         if not val:
326             return self.session_class()
327         max_age = int(app.permanent_session_lifetime.total_seconds())
328         try:
329             data = s.loads(val, max_age=max_age)
330             return self.session_class(data)
331         except BadSignature:
332             return self.session_class()
333 
334     def save_session(
335         self, app: Flask, session: SessionMixin, response: Response
336     ) -> None:
337         name = self.get_cookie_name(app)
338         domain = self.get_cookie_domain(app)
339         path = self.get_cookie_path(app)
340         secure = self.get_cookie_secure(app)
341         samesite = self.get_cookie_samesite(app)
342         httponly = self.get_cookie_httponly(app)
343 
344         # Add a "Vary: Cookie" header if the session was accessed at all.
345         if session.accessed:
346             response.vary.add("Cookie")
347 
348         # If the session is modified to be empty, remove the cookie.
349         # If the session is empty, return without setting the cookie.
350         if not session:
351             if session.modified:
352                 response.delete_cookie(
353                     name,
354                     domain=domain,
355                     path=path,
356                     secure=secure,
357                     samesite=samesite,
358                     httponly=httponly,
359                 )
360                 response.vary.add("Cookie")
361 
362             return
363 
364         if not self.should_set_cookie(app, session):
365             return
366 
367         expires = self.get_expiration_time(app, session)
368         val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]
369         response.set_cookie(
370             name,
371             val,
372             expires=expires,
373             httponly=httponly,
374             domain=domain,
375             path=path,
376             secure=secure,
377             samesite=samesite,
378         )
379         response.vary.add("Cookie")
380 
======================================

FILE NAME : signals.py =====
1 from __future__ import annotations
2 
3 from blinker import Namespace
4 
5 # This namespace is only for signals provided by Flask itself.
6 _signals = Namespace()
7 
8 template_rendered = _signals.signal("template-rendered")
9 before_render_template = _signals.signal("before-render-template")
10 request_started = _signals.signal("request-started")
11 request_finished = _signals.signal("request-finished")
12 request_tearing_down = _signals.signal("request-tearing-down")
13 got_request_exception = _signals.signal("got-request-exception")
14 appcontext_tearing_down = _signals.signal("appcontext-tearing-down")
15 appcontext_pushed = _signals.signal("appcontext-pushed")
16 appcontext_popped = _signals.signal("appcontext-popped")
17 message_flashed = _signals.signal("message-flashed")
18 
======================================

FILE NAME : templating.py =====
1 from __future__ import annotations
2 
3 import typing as t
4 
5 from jinja2 import BaseLoader
6 from jinja2 import Environment as BaseEnvironment
7 from jinja2 import Template
8 from jinja2 import TemplateNotFound
9 
10 from .globals import _cv_app
11 from .globals import _cv_request
12 from .globals import current_app
13 from .globals import request
14 from .helpers import stream_with_context
15 from .signals import before_render_template
16 from .signals import template_rendered
17 
18 if t.TYPE_CHECKING:  # pragma: no cover
19     from .app import Flask
20     from .sansio.app import App
21     from .sansio.scaffold import Scaffold
22 
23 
24 def _default_template_ctx_processor() -> dict[str, t.Any]:
25     """Default template context processor.  Injects `request`,
26     `session` and `g`.
27     """
28     appctx = _cv_app.get(None)
29     reqctx = _cv_request.get(None)
30     rv: dict[str, t.Any] = {}
31     if appctx is not None:
32         rv["g"] = appctx.g
33     if reqctx is not None:
34         rv["request"] = reqctx.request
35         rv["session"] = reqctx.session
36     return rv
37 
38 
39 class Environment(BaseEnvironment):
40     """Works like a regular Jinja2 environment but has some additional
41     knowledge of how Flask's blueprint works so that it can prepend the
42     name of the blueprint to referenced templates if necessary.
43     """
44 
45     def __init__(self, app: App, **options: t.Any) -> None:
46         if "loader" not in options:
47             options["loader"] = app.create_global_jinja_loader()
48         BaseEnvironment.__init__(self, **options)
49         self.app = app
50 
51 
52 class DispatchingJinjaLoader(BaseLoader):
53     """A loader that looks for templates in the application and all
54     the blueprint folders.
55     """
56 
57     def __init__(self, app: App) -> None:
58         self.app = app
59 
60     def get_source(
61         self, environment: BaseEnvironment, template: str
62     ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
63         if self.app.config["EXPLAIN_TEMPLATE_LOADING"]:
64             return self._get_source_explained(environment, template)
65         return self._get_source_fast(environment, template)
66 
67     def _get_source_explained(
68         self, environment: BaseEnvironment, template: str
69     ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
70         attempts = []
71         rv: tuple[str, str | None, t.Callable[[], bool] | None] | None
72         trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None
73 
74         for srcobj, loader in self._iter_loaders(template):
75             try:
76                 rv = loader.get_source(environment, template)
77                 if trv is None:
78                     trv = rv
79             except TemplateNotFound:
80                 rv = None
81             attempts.append((loader, srcobj, rv))
82 
83         from .debughelpers import explain_template_loading_attempts
84 
85         explain_template_loading_attempts(self.app, template, attempts)
86 
87         if trv is not None:
88             return trv
89         raise TemplateNotFound(template)
90 
91     def _get_source_fast(
92         self, environment: BaseEnvironment, template: str
93     ) -> tuple[str, str | None, t.Callable[[], bool] | None]:
94         for _srcobj, loader in self._iter_loaders(template):
95             try:
96                 return loader.get_source(environment, template)
97             except TemplateNotFound:
98                 continue
99         raise TemplateNotFound(template)
100 
101     def _iter_loaders(self, template: str) -> t.Iterator[tuple[Scaffold, BaseLoader]]:
102         loader = self.app.jinja_loader
103         if loader is not None:
104             yield self.app, loader
105 
106         for blueprint in self.app.iter_blueprints():
107             loader = blueprint.jinja_loader
108             if loader is not None:
109                 yield blueprint, loader
110 
111     def list_templates(self) -> list[str]:
112         result = set()
113         loader = self.app.jinja_loader
114         if loader is not None:
115             result.update(loader.list_templates())
116 
117         for blueprint in self.app.iter_blueprints():
118             loader = blueprint.jinja_loader
119             if loader is not None:
120                 for template in loader.list_templates():
121                     result.add(template)
122 
123         return list(result)
124 
125 
126 def _render(app: Flask, template: Template, context: dict[str, t.Any]) -> str:
127     app.update_template_context(context)
128     before_render_template.send(
129         app, _async_wrapper=app.ensure_sync, template=template, context=context
130     )
131     rv = template.render(context)
132     template_rendered.send(
133         app, _async_wrapper=app.ensure_sync, template=template, context=context
134     )
135     return rv
136 
137 
138 def render_template(
139     template_name_or_list: str | Template | list[str | Template],
140     **context: t.Any,
141 ) -> str:
142     """Render a template by name with the given context.
143 
144     :param template_name_or_list: The name of the template to render. If
145         a list is given, the first name to exist will be rendered.
146     :param context: The variables to make available in the template.
147     """
148     app = current_app._get_current_object()  # type: ignore[attr-defined]
149     template = app.jinja_env.get_or_select_template(template_name_or_list)
150     return _render(app, template, context)
151 
152 
153 def render_template_string(source: str, **context: t.Any) -> str:
154     """Render a template from the given source string with the given
155     context.
156 
157     :param source: The source code of the template to render.
158     :param context: The variables to make available in the template.
159     """
160     app = current_app._get_current_object()  # type: ignore[attr-defined]
161     template = app.jinja_env.from_string(source)
162     return _render(app, template, context)
163 
164 
165 def _stream(
166     app: Flask, template: Template, context: dict[str, t.Any]
167 ) -> t.Iterator[str]:
168     app.update_template_context(context)
169     before_render_template.send(
170         app, _async_wrapper=app.ensure_sync, template=template, context=context
171     )
172 
173     def generate() -> t.Iterator[str]:
174         yield from template.generate(context)
175         template_rendered.send(
176             app, _async_wrapper=app.ensure_sync, template=template, context=context
177         )
178 
179     rv = generate()
180 
181     # If a request context is active, keep it while generating.
182     if request:
183         rv = stream_with_context(rv)
184 
185     return rv
186 
187 
188 def stream_template(
189     template_name_or_list: str | Template | list[str | Template],
190     **context: t.Any,
191 ) -> t.Iterator[str]:
192     """Render a template by name with the given context as a stream.
193     This returns an iterator of strings, which can be used as a
194     streaming response from a view.
195 
196     :param template_name_or_list: The name of the template to render. If
197         a list is given, the first name to exist will be rendered.
198     :param context: The variables to make available in the template.
199 
200     .. versionadded:: 2.2
201     """
202     app = current_app._get_current_object()  # type: ignore[attr-defined]
203     template = app.jinja_env.get_or_select_template(template_name_or_list)
204     return _stream(app, template, context)
205 
206 
207 def stream_template_string(source: str, **context: t.Any) -> t.Iterator[str]:
208     """Render a template from the given source string with the given
209     context as a stream. This returns an iterator of strings, which can
210     be used as a streaming response from a view.
211 
212     :param source: The source code of the template to render.
213     :param context: The variables to make available in the template.
214 
215     .. versionadded:: 2.2
216     """
217     app = current_app._get_current_object()  # type: ignore[attr-defined]
218     template = app.jinja_env.from_string(source)
219     return _stream(app, template, context)
220 
======================================

FILE NAME : testing.py =====
1 from __future__ import annotations
2 
3 import importlib.metadata
4 import typing as t
5 from contextlib import contextmanager
6 from contextlib import ExitStack
7 from copy import copy
8 from types import TracebackType
9 from urllib.parse import urlsplit
10 
11 import werkzeug.test
12 from click.testing import CliRunner
13 from werkzeug.test import Client
14 from werkzeug.wrappers import Request as BaseRequest
15 
16 from .cli import ScriptInfo
17 from .sessions import SessionMixin
18 
19 if t.TYPE_CHECKING:  # pragma: no cover
20     from _typeshed.wsgi import WSGIEnvironment
21     from werkzeug.test import TestResponse
22 
23     from .app import Flask
24 
25 
26 class EnvironBuilder(werkzeug.test.EnvironBuilder):
27     """An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the
28     application.
29 
30     :param app: The Flask application to configure the environment from.
31     :param path: URL path being requested.
32     :param base_url: Base URL where the app is being served, which
33         ``path`` is relative to. If not given, built from
34         :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
35         :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
36     :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.
37     :param url_scheme: Scheme to use instead of
38         :data:`PREFERRED_URL_SCHEME`.
39     :param json: If given, this is serialized as JSON and passed as
40         ``data``. Also defaults ``content_type`` to
41         ``application/json``.
42     :param args: other positional arguments passed to
43         :class:`~werkzeug.test.EnvironBuilder`.
44     :param kwargs: other keyword arguments passed to
45         :class:`~werkzeug.test.EnvironBuilder`.
46     """
47 
48     def __init__(
49         self,
50         app: Flask,
51         path: str = "/",
52         base_url: str | None = None,
53         subdomain: str | None = None,
54         url_scheme: str | None = None,
55         *args: t.Any,
56         **kwargs: t.Any,
57     ) -> None:
58         assert not (base_url or subdomain or url_scheme) or (
59             base_url is not None
60         ) != bool(
61             subdomain or url_scheme
62         ), 'Cannot pass "subdomain" or "url_scheme" with "base_url".'
63 
64         if base_url is None:
65             http_host = app.config.get("SERVER_NAME") or "localhost"
66             app_root = app.config["APPLICATION_ROOT"]
67 
68             if subdomain:
69                 http_host = f"{subdomain}.{http_host}"
70 
71             if url_scheme is None:
72                 url_scheme = app.config["PREFERRED_URL_SCHEME"]
73 
74             url = urlsplit(path)
75             base_url = (
76                 f"{url.scheme or url_scheme}://{url.netloc or http_host}"
77                 f"/{app_root.lstrip('/')}"
78             )
79             path = url.path
80 
81             if url.query:
82                 sep = b"?" if isinstance(url.query, bytes) else "?"
83                 path += sep + url.query
84 
85         self.app = app
86         super().__init__(path, base_url, *args, **kwargs)
87 
88     def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:  # type: ignore
89         """Serialize ``obj`` to a JSON-formatted string.
90 
91         The serialization will be configured according to the config associated
92         with this EnvironBuilder's ``app``.
93         """
94         return self.app.json.dumps(obj, **kwargs)
95 
96 
97 _werkzeug_version = ""
98 
99 
100 def _get_werkzeug_version() -> str:
101     global _werkzeug_version
102 
103     if not _werkzeug_version:
104         _werkzeug_version = importlib.metadata.version("werkzeug")
105 
106     return _werkzeug_version
107 
108 
109 class FlaskClient(Client):
110     """Works like a regular Werkzeug test client but has knowledge about
111     Flask's contexts to defer the cleanup of the request context until
112     the end of a ``with`` block. For general information about how to
113     use this class refer to :class:`werkzeug.test.Client`.
114 
115     .. versionchanged:: 0.12
116        `app.test_client()` includes preset default environment, which can be
117        set after instantiation of the `app.test_client()` object in
118        `client.environ_base`.
119 
120     Basic usage is outlined in the :doc:`/testing` chapter.
121     """
122 
123     application: Flask
124 
125     def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
126         super().__init__(*args, **kwargs)
127         self.preserve_context = False
128         self._new_contexts: list[t.ContextManager[t.Any]] = []
129         self._context_stack = ExitStack()
130         self.environ_base = {
131             "REMOTE_ADDR": "127.0.0.1",
132             "HTTP_USER_AGENT": f"Werkzeug/{_get_werkzeug_version()}",
133         }
134 
135     @contextmanager
136     def session_transaction(
137         self, *args: t.Any, **kwargs: t.Any
138     ) -> t.Iterator[SessionMixin]:
139         """When used in combination with a ``with`` statement this opens a
140         session transaction.  This can be used to modify the session that
141         the test client uses.  Once the ``with`` block is left the session is
142         stored back.
143 
144         ::
145 
146             with client.session_transaction() as session:
147                 session['value'] = 42
148 
149         Internally this is implemented by going through a temporary test
150         request context and since session handling could depend on
151         request variables this function accepts the same arguments as
152         :meth:`~flask.Flask.test_request_context` which are directly
153         passed through.
154         """
155         if self._cookies is None:
156             raise TypeError(
157                 "Cookies are disabled. Create a client with 'use_cookies=True'."
158             )
159 
160         app = self.application
161         ctx = app.test_request_context(*args, **kwargs)
162         self._add_cookies_to_wsgi(ctx.request.environ)
163 
164         with ctx:
165             sess = app.session_interface.open_session(app, ctx.request)
166 
167         if sess is None:
168             raise RuntimeError("Session backend did not open a session.")
169 
170         yield sess
171         resp = app.response_class()
172 
173         if app.session_interface.is_null_session(sess):
174             return
175 
176         with ctx:
177             app.session_interface.save_session(app, sess, resp)
178 
179         self._update_cookies_from_response(
180             ctx.request.host.partition(":")[0],
181             ctx.request.path,
182             resp.headers.getlist("Set-Cookie"),
183         )
184 
185     def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:
186         out = {**self.environ_base, **other}
187 
188         if self.preserve_context:
189             out["werkzeug.debug.preserve_context"] = self._new_contexts.append
190 
191         return out
192 
193     def _request_from_builder_args(
194         self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]
195     ) -> BaseRequest:
196         kwargs["environ_base"] = self._copy_environ(kwargs.get("environ_base", {}))
197         builder = EnvironBuilder(self.application, *args, **kwargs)
198 
199         try:
200             return builder.get_request()
201         finally:
202             builder.close()
203 
204     def open(
205         self,
206         *args: t.Any,
207         buffered: bool = False,
208         follow_redirects: bool = False,
209         **kwargs: t.Any,
210     ) -> TestResponse:
211         if args and isinstance(
212             args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)
213         ):
214             if isinstance(args[0], werkzeug.test.EnvironBuilder):
215                 builder = copy(args[0])
216                 builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]
217                 request = builder.get_request()
218             elif isinstance(args[0], dict):
219                 request = EnvironBuilder.from_environ(
220                     args[0], app=self.application, environ_base=self._copy_environ({})
221                 ).get_request()
222             else:
223                 # isinstance(args[0], BaseRequest)
224                 request = copy(args[0])
225                 request.environ = self._copy_environ(request.environ)
226         else:
227             # request is None
228             request = self._request_from_builder_args(args, kwargs)
229 
230         # Pop any previously preserved contexts. This prevents contexts
231         # from being preserved across redirects or multiple requests
232         # within a single block.
233         self._context_stack.close()
234 
235         response = super().open(
236             request,
237             buffered=buffered,
238             follow_redirects=follow_redirects,
239         )
240         response.json_module = self.application.json  # type: ignore[assignment]
241 
242         # Re-push contexts that were preserved during the request.
243         while self._new_contexts:
244             cm = self._new_contexts.pop()
245             self._context_stack.enter_context(cm)
246 
247         return response
248 
249     def __enter__(self) -> FlaskClient:
250         if self.preserve_context:
251             raise RuntimeError("Cannot nest client invocations")
252         self.preserve_context = True
253         return self
254 
255     def __exit__(
256         self,
257         exc_type: type | None,
258         exc_value: BaseException | None,
259         tb: TracebackType | None,
260     ) -> None:
261         self.preserve_context = False
262         self._context_stack.close()
263 
264 
265 class FlaskCliRunner(CliRunner):
266     """A :class:`~click.testing.CliRunner` for testing a Flask app's
267     CLI commands. Typically created using
268     :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.
269     """
270 
271     def __init__(self, app: Flask, **kwargs: t.Any) -> None:
272         self.app = app
273         super().__init__(**kwargs)
274 
275     def invoke(  # type: ignore
276         self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
277     ) -> t.Any:
278         """Invokes a CLI command in an isolated environment. See
279         :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
280         full method documentation. See :ref:`testing-cli` for examples.
281 
282         If the ``obj`` argument is not given, passes an instance of
283         :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
284         app being tested.
285 
286         :param cli: Command object to invoke. Default is the app's
287             :attr:`~flask.app.Flask.cli` group.
288         :param args: List of strings to invoke the command with.
289 
290         :return: a :class:`~click.testing.Result` object.
291         """
292         if cli is None:
293             cli = self.app.cli
294 
295         if "obj" not in kwargs:
296             kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
297 
298         return super().invoke(cli, args, **kwargs)
299 
======================================

FILE NAME : typing.py =====
1 from __future__ import annotations
2 
3 import typing as t
4 
5 if t.TYPE_CHECKING:  # pragma: no cover
6     from _typeshed.wsgi import WSGIApplication  # noqa: F401
7     from werkzeug.datastructures import Headers  # noqa: F401
8     from werkzeug.sansio.response import Response  # noqa: F401
9 
10 # The possible types that are directly convertible or are a Response object.
11 ResponseValue = t.Union[
12     "Response",
13     str,
14     bytes,
15     t.List[t.Any],
16     # Only dict is actually accepted, but Mapping allows for TypedDict.
17     t.Mapping[str, t.Any],
18     t.Iterator[str],
19     t.Iterator[bytes],
20 ]
21 
22 # the possible types for an individual HTTP header
23 # This should be a Union, but mypy doesn't pass unless it's a TypeVar.
24 HeaderValue = t.Union[str, t.List[str], t.Tuple[str, ...]]
25 
26 # the possible types for HTTP headers
27 HeadersValue = t.Union[
28     "Headers",
29     t.Mapping[str, HeaderValue],
30     t.Sequence[t.Tuple[str, HeaderValue]],
31 ]
32 
33 # The possible types returned by a route function.
34 ResponseReturnValue = t.Union[
35     ResponseValue,
36     t.Tuple[ResponseValue, HeadersValue],
37     t.Tuple[ResponseValue, int],
38     t.Tuple[ResponseValue, int, HeadersValue],
39     "WSGIApplication",
40 ]
41 
42 # Allow any subclass of werkzeug.Response, such as the one from Flask,
43 # as a callback argument. Using werkzeug.Response directly makes a
44 # callback annotated with flask.Response fail type checking.
45 ResponseClass = t.TypeVar("ResponseClass", bound="Response")
46 
47 AppOrBlueprintKey = t.Optional[str]  # The App key is None, whereas blueprints are named
48 AfterRequestCallable = t.Union[
49     t.Callable[[ResponseClass], ResponseClass],
50     t.Callable[[ResponseClass], t.Awaitable[ResponseClass]],
51 ]
52 BeforeFirstRequestCallable = t.Union[
53     t.Callable[[], None], t.Callable[[], t.Awaitable[None]]
54 ]
55 BeforeRequestCallable = t.Union[
56     t.Callable[[], t.Optional[ResponseReturnValue]],
57     t.Callable[[], t.Awaitable[t.Optional[ResponseReturnValue]]],
58 ]
59 ShellContextProcessorCallable = t.Callable[[], t.Dict[str, t.Any]]
60 TeardownCallable = t.Union[
61     t.Callable[[t.Optional[BaseException]], None],
62     t.Callable[[t.Optional[BaseException]], t.Awaitable[None]],
63 ]
64 TemplateContextProcessorCallable = t.Union[
65     t.Callable[[], t.Dict[str, t.Any]],
66     t.Callable[[], t.Awaitable[t.Dict[str, t.Any]]],
67 ]
68 TemplateFilterCallable = t.Callable[..., t.Any]
69 TemplateGlobalCallable = t.Callable[..., t.Any]
70 TemplateTestCallable = t.Callable[..., bool]
71 URLDefaultCallable = t.Callable[[str, t.Dict[str, t.Any]], None]
72 URLValuePreprocessorCallable = t.Callable[
73     [t.Optional[str], t.Optional[t.Dict[str, t.Any]]], None
74 ]
75 
76 # This should take Exception, but that either breaks typing the argument
77 # with a specific exception, or decorating multiple times with different
78 # exceptions (and using a union type on the argument).
79 # https://github.com/pallets/flask/issues/4095
80 # https://github.com/pallets/flask/issues/4295
81 # https://github.com/pallets/flask/issues/4297
82 ErrorHandlerCallable = t.Union[
83     t.Callable[[t.Any], ResponseReturnValue],
84     t.Callable[[t.Any], t.Awaitable[ResponseReturnValue]],
85 ]
86 
87 RouteCallable = t.Union[
88     t.Callable[..., ResponseReturnValue],
89     t.Callable[..., t.Awaitable[ResponseReturnValue]],
90 ]
91 
======================================

FILE NAME : views.py =====
1 from __future__ import annotations
2 
3 import typing as t
4 
5 from . import typing as ft
6 from .globals import current_app
7 from .globals import request
8 
9 F = t.TypeVar("F", bound=t.Callable[..., t.Any])
10 
11 http_method_funcs = frozenset(
12     ["get", "post", "head", "options", "delete", "put", "trace", "patch"]
13 )
14 
15 
16 class View:
17     """Subclass this class and override :meth:`dispatch_request` to
18     create a generic class-based view. Call :meth:`as_view` to create a
19     view function that creates an instance of the class with the given
20     arguments and calls its ``dispatch_request`` method with any URL
21     variables.
22 
23     See :doc:`views` for a detailed guide.
24 
25     .. code-block:: python
26 
27         class Hello(View):
28             init_every_request = False
29 
30             def dispatch_request(self, name):
31                 return f"Hello, {name}!"
32 
33         app.add_url_rule(
34             "/hello/<name>", view_func=Hello.as_view("hello")
35         )
36 
37     Set :attr:`methods` on the class to change what methods the view
38     accepts.
39 
40     Set :attr:`decorators` on the class to apply a list of decorators to
41     the generated view function. Decorators applied to the class itself
42     will not be applied to the generated view function!
43 
44     Set :attr:`init_every_request` to ``False`` for efficiency, unless
45     you need to store request-global data on ``self``.
46     """
47 
48     #: The methods this view is registered for. Uses the same default
49     #: (``["GET", "HEAD", "OPTIONS"]``) as ``route`` and
50     #: ``add_url_rule`` by default.
51     methods: t.ClassVar[t.Collection[str] | None] = None
52 
53     #: Control whether the ``OPTIONS`` method is handled automatically.
54     #: Uses the same default (``True``) as ``route`` and
55     #: ``add_url_rule`` by default.
56     provide_automatic_options: t.ClassVar[bool | None] = None
57 
58     #: A list of decorators to apply, in order, to the generated view
59     #: function. Remember that ``@decorator`` syntax is applied bottom
60     #: to top, so the first decorator in the list would be the bottom
61     #: decorator.
62     #:
63     #: .. versionadded:: 0.8
64     decorators: t.ClassVar[list[t.Callable[[F], F]]] = []
65 
66     #: Create a new instance of this view class for every request by
67     #: default. If a view subclass sets this to ``False``, the same
68     #: instance is used for every request.
69     #:
70     #: A single instance is more efficient, especially if complex setup
71     #: is done during init. However, storing data on ``self`` is no
72     #: longer safe across requests, and :data:`~flask.g` should be used
73     #: instead.
74     #:
75     #: .. versionadded:: 2.2
76     init_every_request: t.ClassVar[bool] = True
77 
78     def dispatch_request(self) -> ft.ResponseReturnValue:
79         """The actual view function behavior. Subclasses must override
80         this and return a valid response. Any variables from the URL
81         rule are passed as keyword arguments.
82         """
83         raise NotImplementedError()
84 
85     @classmethod
86     def as_view(
87         cls, name: str, *class_args: t.Any, **class_kwargs: t.Any
88     ) -> ft.RouteCallable:
89         """Convert the class into a view function that can be registered
90         for a route.
91 
92         By default, the generated view will create a new instance of the
93         view class for every request and call its
94         :meth:`dispatch_request` method. If the view class sets
95         :attr:`init_every_request` to ``False``, the same instance will
96         be used for every request.
97 
98         Except for ``name``, all other arguments passed to this method
99         are forwarded to the view class ``__init__`` method.
100 
101         .. versionchanged:: 2.2
102             Added the ``init_every_request`` class attribute.
103         """
104         if cls.init_every_request:
105 
106             def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
107                 self = view.view_class(  # type: ignore[attr-defined]
108                     *class_args, **class_kwargs
109                 )
110                 return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]
111 
112         else:
113             self = cls(*class_args, **class_kwargs)
114 
115             def view(**kwargs: t.Any) -> ft.ResponseReturnValue:
116                 return current_app.ensure_sync(self.dispatch_request)(**kwargs)  # type: ignore[no-any-return]
117 
118         if cls.decorators:
119             view.__name__ = name
120             view.__module__ = cls.__module__
121             for decorator in cls.decorators:
122                 view = decorator(view)
123 
124         # We attach the view class to the view function for two reasons:
125         # first of all it allows us to easily figure out what class-based
126         # view this thing came from, secondly it's also used for instantiating
127         # the view class so you can actually replace it with something else
128         # for testing purposes and debugging.
129         view.view_class = cls  # type: ignore
130         view.__name__ = name
131         view.__doc__ = cls.__doc__
132         view.__module__ = cls.__module__
133         view.methods = cls.methods  # type: ignore
134         view.provide_automatic_options = cls.provide_automatic_options  # type: ignore
135         return view
136 
137 
138 class MethodView(View):
139     """Dispatches request methods to the corresponding instance methods.
140     For example, if you implement a ``get`` method, it will be used to
141     handle ``GET`` requests.
142 
143     This can be useful for defining a REST API.
144 
145     :attr:`methods` is automatically set based on the methods defined on
146     the class.
147 
148     See :doc:`views` for a detailed guide.
149 
150     .. code-block:: python
151 
152         class CounterAPI(MethodView):
153             def get(self):
154                 return str(session.get("counter", 0))
155 
156             def post(self):
157                 session["counter"] = session.get("counter", 0) + 1
158                 return redirect(url_for("counter"))
159 
160         app.add_url_rule(
161             "/counter", view_func=CounterAPI.as_view("counter")
162         )
163     """
164 
165     def __init_subclass__(cls, **kwargs: t.Any) -> None:
166         super().__init_subclass__(**kwargs)
167 
168         if "methods" not in cls.__dict__:
169             methods = set()
170 
171             for base in cls.__bases__:
172                 if getattr(base, "methods", None):
173                     methods.update(base.methods)  # type: ignore[attr-defined]
174 
175             for key in http_method_funcs:
176                 if hasattr(cls, key):
177                     methods.add(key.upper())
178 
179             if methods:
180                 cls.methods = methods
181 
182     def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:
183         meth = getattr(self, request.method.lower(), None)
184 
185         # If the request method is HEAD and we don't have a handler for it
186         # retry with GET.
187         if meth is None and request.method == "HEAD":
188             meth = getattr(self, "get", None)
189 
190         assert meth is not None, f"Unimplemented method {request.method!r}"
191         return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]
192 
======================================

FILE NAME : wrappers.py =====
1 from __future__ import annotations
2 
3 import typing as t
4 
5 from werkzeug.exceptions import BadRequest
6 from werkzeug.exceptions import HTTPException
7 from werkzeug.wrappers import Request as RequestBase
8 from werkzeug.wrappers import Response as ResponseBase
9 
10 from . import json
11 from .globals import current_app
12 from .helpers import _split_blueprint_path
13 
14 if t.TYPE_CHECKING:  # pragma: no cover
15     from werkzeug.routing import Rule
16 
17 
18 class Request(RequestBase):
19     """The request object used by default in Flask.  Remembers the
20     matched endpoint and view arguments.
21 
22     It is what ends up as :class:`~flask.request`.  If you want to replace
23     the request object used you can subclass this and set
24     :attr:`~flask.Flask.request_class` to your subclass.
25 
26     The request object is a :class:`~werkzeug.wrappers.Request` subclass and
27     provides all of the attributes Werkzeug defines plus a few Flask
28     specific ones.
29     """
30 
31     json_module: t.Any = json
32 
33     #: The internal URL rule that matched the request.  This can be
34     #: useful to inspect which methods are allowed for the URL from
35     #: a before/after handler (``request.url_rule.methods``) etc.
36     #: Though if the request's method was invalid for the URL rule,
37     #: the valid list is available in ``routing_exception.valid_methods``
38     #: instead (an attribute of the Werkzeug exception
39     #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)
40     #: because the request was never internally bound.
41     #:
42     #: .. versionadded:: 0.6
43     url_rule: Rule | None = None
44 
45     #: A dict of view arguments that matched the request.  If an exception
46     #: happened when matching, this will be ``None``.
47     view_args: dict[str, t.Any] | None = None
48 
49     #: If matching the URL failed, this is the exception that will be
50     #: raised / was raised as part of the request handling.  This is
51     #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or
52     #: something similar.
53     routing_exception: HTTPException | None = None
54 
55     @property
56     def max_content_length(self) -> int | None:  # type: ignore[override]
57         """Read-only view of the ``MAX_CONTENT_LENGTH`` config key."""
58         if current_app:
59             return current_app.config["MAX_CONTENT_LENGTH"]  # type: ignore[no-any-return]
60         else:
61             return None
62 
63     @property
64     def endpoint(self) -> str | None:
65         """The endpoint that matched the request URL.
66 
67         This will be ``None`` if matching failed or has not been
68         performed yet.
69 
70         This in combination with :attr:`view_args` can be used to
71         reconstruct the same URL or a modified URL.
72         """
73         if self.url_rule is not None:
74             return self.url_rule.endpoint  # type: ignore[no-any-return]
75 
76         return None
77 
78     @property
79     def blueprint(self) -> str | None:
80         """The registered name of the current blueprint.
81 
82         This will be ``None`` if the endpoint is not part of a
83         blueprint, or if URL matching failed or has not been performed
84         yet.
85 
86         This does not necessarily match the name the blueprint was
87         created with. It may have been nested, or registered with a
88         different name.
89         """
90         endpoint = self.endpoint
91 
92         if endpoint is not None and "." in endpoint:
93             return endpoint.rpartition(".")[0]
94 
95         return None
96 
97     @property
98     def blueprints(self) -> list[str]:
99         """The registered names of the current blueprint upwards through
100         parent blueprints.
101 
102         This will be an empty list if there is no current blueprint, or
103         if URL matching failed.
104 
105         .. versionadded:: 2.0.1
106         """
107         name = self.blueprint
108 
109         if name is None:
110             return []
111 
112         return _split_blueprint_path(name)
113 
114     def _load_form_data(self) -> None:
115         super()._load_form_data()
116 
117         # In debug mode we're replacing the files multidict with an ad-hoc
118         # subclass that raises a different error for key errors.
119         if (
120             current_app
121             and current_app.debug
122             and self.mimetype != "multipart/form-data"
123             and not self.files
124         ):
125             from .debughelpers import attach_enctype_error_multidict
126 
127             attach_enctype_error_multidict(self)
128 
129     def on_json_loading_failed(self, e: ValueError | None) -> t.Any:
130         try:
131             return super().on_json_loading_failed(e)
132         except BadRequest as e:
133             if current_app and current_app.debug:
134                 raise
135 
136             raise BadRequest() from e
137 
138 
139 class Response(ResponseBase):
140     """The response object that is used by default in Flask.  Works like the
141     response object from Werkzeug but is set to have an HTML mimetype by
142     default.  Quite often you don't have to create this object yourself because
143     :meth:`~flask.Flask.make_response` will take care of that for you.
144 
145     If you want to replace the response object used you can subclass this and
146     set :attr:`~flask.Flask.response_class` to your subclass.
147 
148     .. versionchanged:: 1.0
149         JSON support is added to the response, like the request. This is useful
150         when testing to get the test client response data as JSON.
151 
152     .. versionchanged:: 1.0
153 
154         Added :attr:`max_cookie_size`.
155     """
156 
157     default_mimetype: str | None = "text/html"
158 
159     json_module = json
160 
161     autocorrect_location_header = False
162 
163     @property
164     def max_cookie_size(self) -> int:  # type: ignore
165         """Read-only view of the :data:`MAX_COOKIE_SIZE` config key.
166 
167         See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in
168         Werkzeug's docs.
169         """
170         if current_app:
171             return current_app.config["MAX_COOKIE_SIZE"]  # type: ignore[no-any-return]
172 
173         # return Werkzeug's default when not in an app context
174         return super().max_cookie_size
175 
======================================
